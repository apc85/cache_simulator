        -:    0:Source:gui.c
        -:    0:Graph:gui.gcno
        -:    0:Data:gui.gcda
        -:    0:Runs:17
        -:    0:Programs:1
        -:    1:﻿#include <math.h>
        -:    2:#include "gui.h"
        -:    3:#include "datainterface.h"
        -:    4:#include "datastore.h"
        -:    5:#include "callbacks.h"
        -:    6:
        -:    7:int useGUI=1;
        -:    8:
        -:    9:/**
        -:   10: * Function to create the GUI. Data structures for the gui tables must have been created previously.
        -:   11: */
        3:   12:int generateGUI(int argc, char *argv[]) {
        3:   13:   if(!useGUI) {
    #####:   14:      return 0;
        -:   15:   }
        -:   16:   //esto se usara mas adelante. Es para colorear texts.
        3:   17:   tagBlue = gtk_text_buffer_create_tag (buffer, "blue_foreground", "foreground", "blue", NULL);
        3:   18:   tagBlack = gtk_text_buffer_create_tag (buffer, "black_foreground", "foreground", "black", NULL);
        -:   19:   //Esto tabién se usara mas adelante es para recorrer el buffer de text del file trace
        3:   20:   gtk_text_buffer_get_iter_at_offset (buffer, &lineIterInicial, 0);
        3:   21:   marcaLineCurrent= gtk_text_mark_new (NULL, 1);
        3:   22:   gtk_text_buffer_add_mark (buffer,
        -:   23:         marcaLineCurrent,
        -:   24:         &lineIterInicial);
        -:   25:   /* This is called in all GTK applications. Arguments are parsed
        -:   26:    * from the command line and are returned, to the application. */
        3:   27:   gtk_init (&argc, &argv);
        -:   28:   /* create a new window */
        3:   29:   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
        3:   30:   gtk_window_set_default_size(GTK_WINDOW(window), 700, 400);
        -:   31:   /* When the window is given the "delete_event" signal (this is given
        -:   32:    * by the window manager, usually by the "close" option, or on the
        -:   33:    * titlebar), we ask it to call the delete_event () function
        -:   34:    * as defined above. The data passed to the callback
        -:   35:    * function is NULL and is ignored in the callback function. */
        3:   36:   g_signal_connect (G_OBJECT (window), "delete_event",
        -:   37:         G_CALLBACK (delete_event), NULL);
        -:   38:   /* Here we connect the "destroy" event to a signal handler.
        -:   39:    * This event occurs when we call gtk_widget_destroy() on the window,
        -:   40:    * or if we return FALSE in the "delete_event" callback. */
        3:   41:   g_signal_connect (G_OBJECT (window), "destroy",
        -:   42:         G_CALLBACK (destroy), NULL);
        -:   43:   /* Sets the border width of the window. */
        3:   44:   gtk_container_set_border_width (GTK_CONTAINER (window), 5);
        3:   45:   verticalBox= gtk_vbox_new (FALSE, 5);
        3:   46:   gtk_container_add (GTK_CONTAINER (window), verticalBox);
        3:   47:   buttonBox= gtk_hbox_new (FALSE, 10);
        -:   48:   //gtk_container_add (GTK_CONTAINER (verticalBox), buttonBox);
        3:   49:   gtk_box_pack_start (GTK_BOX(verticalBox), buttonBox, FALSE, FALSE, 5);
        3:   50:   button1= gtk_button_new_with_label ("Next step");
        3:   51:   button2= gtk_button_new_with_label ("Simulate all");
        3:   52:   button3= gtk_button_new_with_label ("Restart");
        3:   53:   g_signal_connect (button1, "clicked", G_CALLBACK (callbackNextStep), (gpointer) NULL);
        3:   54:   g_signal_connect (button2, "clicked", G_CALLBACK (callbackSimulateAll), (gpointer) NULL);
        3:   55:   g_signal_connect (button3, "clicked", G_CALLBACK (callbackRestart), (gpointer) NULL);
        -:   56:   //gtk_container_add (GTK_CONTAINER (buttonBox), button1);
        -:   57:   //gtk_container_add (GTK_CONTAINER (buttonBox), button2);
        3:   58:   gtk_box_pack_start (GTK_BOX(buttonBox), button1, FALSE, FALSE, 5);
        3:   59:   gtk_box_pack_start (GTK_BOX(buttonBox), button2, FALSE, FALSE, 5);
        3:   60:   gtk_box_pack_start (GTK_BOX(buttonBox), button3, FALSE, FALSE, 5);
        -:   61:#if DEBUG
        3:   62:   button4= gtk_button_new_with_label ("Test");
        3:   63:   g_signal_connect (button4, "clicked", G_CALLBACK (callbackTest), (gpointer) NULL);
        3:   64:   gtk_box_pack_start (GTK_BOX(buttonBox), button4, FALSE, FALSE, 5);
        -:   65:#endif
        -:   66:   ///creo la tabla para los paneles
        3:   67:   table = gtk_table_new (2, 4, TRUE);
        -:   68:   /* Coloca la tabla en la ventana principal */
        -:   69:   //gtk_container_add (GTK_CONTAINER (verticalBox), table);
        3:   70:   gtk_box_pack_start (GTK_BOX(verticalBox), table, TRUE, TRUE, 5);
        3:   71:   gtk_table_set_row_spacings(GTK_TABLE(table), 10);
        3:   72:   gtk_table_set_col_spacings(GTK_TABLE(table), 10);
        -:   73:   ///creo los buttones
        -:   74:   /* Creo la columna que representa a la memory */
        3:   75:   createPanelMemory();
        9:   76:   for(int i=0; i<numberCaches; i++) {
        6:   77:      createPanelCache(i);
        -:   78:   }
        3:   79:   vboxText  = gtk_vbox_new(FALSE, 2);
        -:   80:   //creo el text view
        -:   81:   //buffer = gtk_text_buffer_new (NULL);
        3:   82:   text_view = gtk_text_view_new_with_buffer (buffer);
        3:   83:   gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (text_view), GTK_WRAP_NONE);
        3:   84:   scrolled_window = gtk_scrolled_window_new (NULL, NULL);
        3:   85:   gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
        3:   86:   gtk_container_add(GTK_CONTAINER(scrolled_window), text_view);
        -:   87:   //insertTextInPanel("holamundo");
        -:   88:   //creo su tag
        -:   89:   char cadena[200];
        3:   90:   sprintf(cadena, "TRACE FILE: %s", cpu.trace_file);
        -:   91:   GtkWidget *label;
        3:   92:   label =gtk_label_new (cadena);
        3:   93:   create_view_statistics();
        3:   94:   vbox_statistics  = gtk_vbox_new(FALSE, 2);
        -:   95:   //creo el text view
        -:   96:   //buffer = gtk_text_buffer_new (NULL);
        -:   97:   //text_view = gtk_text_view_new_with_buffer (buffer);
        -:   98:   //gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (text_view), GTK_WRAP_NONE);
        3:   99:   scrolled_window2 = gtk_scrolled_window_new (NULL, NULL);
        3:  100:   gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
        3:  101:   gtk_container_add(GTK_CONTAINER(scrolled_window2), estatistics_view);
        -:  102:   //insertTextInPanel("holamundo");
        -:  103:   //creo su tag
        3:  104:   sprintf(cadena, "Simulation statistics");
        -:  105:   GtkWidget *label2;
        3:  106:   label2 =gtk_label_new (cadena);
        3:  107:   gtk_box_pack_start(GTK_BOX(vboxText), label, FALSE, FALSE, 1);
        3:  108:   gtk_box_pack_start(GTK_BOX(vboxText), scrolled_window, TRUE, TRUE, 1);
        3:  109:   gtk_box_pack_start(GTK_BOX(vbox_statistics), label2, FALSE, FALSE, 1);
        3:  110:   gtk_box_pack_start(GTK_BOX(vbox_statistics), scrolled_window2, TRUE, TRUE, 1);
        -:  111:   //gtk_container_add (GTK_CONTAINER (scrolled_window), text_view);
        -:  112:   //gtk_container_add (GTK_CONTAINER (scrolled_window), scrolled_window);
        -:  113:   // Coloco los buttones en la tabla
        -:  114:   //printf("%d\n", numberCaches);
        3:  115:   gtk_table_attach_defaults (GTK_TABLE (table), vboxText, 0, 1, 0, 1);
        3:  116:   gtk_table_attach_defaults (GTK_TABLE (table), vbox_statistics, 0, 1, 1, 2);
        3:  117:   gtk_table_attach_defaults (GTK_TABLE (table), vboxMEMORY, numberCaches+1, numberCaches+2, 0, 2);
        9:  118:   for(int i=0; i<numberCaches; i++) {
        6:  119:      if(!caches[i].separated) {
        3:  120:         gtk_table_attach_defaults (GTK_TABLE (table), cacheLevelPanels[i].vboxData, 1+i, 2+i, 0, 2);
        -:  121:      } else {
        3:  122:         gtk_table_attach_defaults (GTK_TABLE (table), cacheLevelPanels[i].vboxData, 1+i, 2+i, 0, 1);
        3:  123:         gtk_table_attach_defaults (GTK_TABLE (table), cacheLevelPanels[i].vboxInstruction, 1+i, 2+i, 1, 2);
        -:  124:      }
        -:  125:   }
        -:  126:   //gtk_table_attach_defaults (GTK_TABLE (table), button2, 1, 2, 0, 2);
        -:  127:   //gtk_table_attach_defaults (GTK_TABLE (table), button3, 2, 3, 0, 2);
        -:  128:   //insertTextInPanel("holamundo");
        -:  129:   /* and the window */
        3:  130:   gtk_widget_show_all(window);
        -:  131:   /* All GTK applications must have a gtk_main(). Control ends here
        -:  132:    * and waits for an event to occur (like a key press or
        -:  133:    * mouse event). */
        3:  134:   gtk_main();
        3:  135:   return 1;
        -:  136:}
        -:  137:
        -:  138:/*
        -:  139: *  Get the next line from the trace file stored in the text widget.
        -:  140: *  
        -:  141: */
       99:  142:char *nextLineTrace() {
        -:  143:   GtkTextIter lineIterCurrent;
       99:  144:   gtk_text_buffer_get_iter_at_mark (buffer, &lineIterCurrent, marcaLineCurrent);
        -:  145:   GtkTextIter start;
       99:  146:   gtk_text_buffer_get_iter_at_offset (buffer, &start, 0);
       99:  147:   GtkTextIter end=lineIterCurrent;
       99:  148:   GtkTextIter lineIterSiguiente=lineIterCurrent;
       99:  149:   gtk_text_view_forward_display_line (GTK_TEXT_VIEW(text_view), &lineIterSiguiente);
        -:  150:   /*
        -:  151:      gtk_text_buffer_remove_tag (buffer,
        -:  152:      tagBlue,
        -:  153:      &start,
        -:  154:      &end);
        -:  155:    */
        -:  156:   //coloreo de negro la linea anterior
       99:  157:   gtk_text_buffer_apply_tag (buffer, tagBlack, &start, &end);
        -:  158:   //coloreo de azul la line current
       99:  159:   gtk_text_buffer_apply_tag (buffer, tagBlue, &lineIterCurrent, &lineIterSiguiente);
        -:  160:   //scroll until new line is visible
       99:  161:   gtk_text_view_scroll_to_iter (GTK_TEXT_VIEW(text_view), &lineIterCurrent, 0.0, 0, 0.0, 0.0);
        -:  162:   //Store the current line
       99:  163:   char *currentLine = gtk_text_buffer_get_text (buffer, &lineIterCurrent, &lineIterSiguiente, 1);
        -:  164:   //printf("%s", lineCurrent);
       99:  165:   gtk_text_view_forward_display_line (GTK_TEXT_VIEW(text_view), &lineIterCurrent);
       99:  166:   gtk_text_buffer_move_mark (buffer, marcaLineCurrent, &lineIterCurrent);
        -:  167:   //gtk_text_buffer_add_mark (buffer, marcaLineCurrent, &lineIterCurrent);
        -:  168:
       99:  169:   if(currentLine[0]=='\0'){
        3:  170:       return NULL;
        -:  171:   }
        -:  172:    
       96:  173:   return currentLine;
        -:  174:}
        -:  175:
        -:  176:/*
        -:  177: * Funtion to create the Memory Panel for the GUI. Memory data structure must have been created previously.
        -:  178: */
        3:  179:GtkWidget * createPanelMemory() {
        -:  180:   GtkTreeIter   iter;
        -:  181:   GtkTreeViewColumn* column;
        3:  182:   vboxMEMORY = gtk_vbox_new(FALSE, 2);
        -:  183:   //createMemoryModel();
        3:  184:   viewMEMORY = gtk_tree_view_new_with_model(GTK_TREE_MODEL(modelMEMORY));
        3:  185:   GtkTreeSelection * selection= gtk_tree_view_get_selection (GTK_TREE_VIEW(viewMEMORY));
        3:  186:   gtk_tree_selection_set_mode (selection, GTK_SELECTION_NONE);
        3:  187:   column = gtk_tree_view_column_new_with_attributes("Address",
        -:  188:         gtk_cell_renderer_text_new(),
        -:  189:         "text", ADDRESS,
        -:  190:         "background", COLOR,
        -:  191:         NULL);
        3:  192:   gtk_tree_view_append_column(GTK_TREE_VIEW(viewMEMORY), column);
        3:  193:   column = gtk_tree_view_column_new_with_attributes("Content",
        -:  194:         gtk_cell_renderer_text_new(),
        -:  195:         "text", CONTENT,
        -:  196:         "background", COLOR,
        -:  197:         NULL);
        3:  198:   gtk_tree_view_append_column(GTK_TREE_VIEW(viewMEMORY), column);
        3:  199:   GtkWidget *scwin = gtk_scrolled_window_new(NULL, NULL);
        3:  200:   gtk_container_add(GTK_CONTAINER(scwin), viewMEMORY);
        3:  201:   gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scwin), GTK_POLICY_AUTOMATIC,
        -:  202:         GTK_POLICY_ALWAYS);
        -:  203:   GtkWidget *label;
        3:  204:   label =gtk_label_new ("MEMORY");
        3:  205:   gtk_box_pack_start(GTK_BOX(vboxMEMORY), label, FALSE, FALSE, 1);
        3:  206:   gtk_box_pack_start(GTK_BOX(vboxMEMORY), scwin, TRUE, TRUE, 1);
        3:  207:   return vboxMEMORY;
        -:  208:}
        -:  209:
        -:  210:/**
        -:  211: * Function to create the GUI panels of a cache level. Cache data structure must have been created previously.
        -:  212: * @param level whose GUI panel will be generated.
        -:  213: *
        -:  214: */
        6:  215:void createPanelCache(int level) {
        -:  216:   //char* mask="11000011";
        6:  217:   const char* mask= caches[level].column_bit_mask;
        -:  218:   //Creo la cache. en caso de que sea dividia esta será la parte de data
        -:  219:   GtkTreeIter   iter;
        -:  220:   GtkTreeViewColumn* column;
        -:  221:   GtkListStore *modelData;
        -:  222:   GtkWidget *vboxData;
        -:  223:   GtkWidget *viewData;
        6:  224:   vboxData = gtk_vbox_new(FALSE, 2);
        6:  225:   int numLines=caches[level].size/caches[level].line_size;
        6:  226:   int asociativity=caches[level].asociativity;
        6:  227:   int numsets=numLines/asociativity;
        6:  228:   int numWords=(caches[level].line_size*8)/cpu.word_width;
        -:  229:   //printf("\ncache level %d: lines: %d, asociativity: %d, sets: %d, words line: %d\n", level+1, numLines, asociativity, numsets, numWords);
        -:  230:   //createCacheModel(level);
        6:  231:   modelData=cacheLevels[level].modelData;
        6:  232:   viewData = gtk_tree_view_new_with_model(GTK_TREE_MODEL(modelData));
        6:  233:   GtkTreeSelection * selectionData= gtk_tree_view_get_selection (GTK_TREE_VIEW(viewData));
        6:  234:   gtk_tree_selection_set_mode (selectionData, GTK_SELECTION_NONE);
        -:  235:   //CREO LAS COLUMNAS A MOSTRAR EN LA TABLA. No confundir con las columnas de la estructura de dados model
        6:  236:   if(mask[LINE]=='1'){
        6:  237:      column = gtk_tree_view_column_new_with_attributes("Line",
        -:  238:            gtk_cell_renderer_text_new(),
        -:  239:            "text", LINE,
        -:  240:            "background", COLOR_CACHE,
        -:  241:            NULL);
        6:  242:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  243:   }
        6:  244:   if(mask[SET]=='1'){
        6:  245:      column = gtk_tree_view_column_new_with_attributes("Set",
        -:  246:            gtk_cell_renderer_text_new(),
        -:  247:            "text", SET,
        -:  248:            "background", COLOR_CACHE,
        -:  249:            NULL);
        6:  250:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  251:   }
        6:  252:   if(mask[VALID]=='1'){
    #####:  253:      column = gtk_tree_view_column_new_with_attributes("valid",
        -:  254:            gtk_cell_renderer_text_new(),
        -:  255:            "text", VALID,
        -:  256:            "background", COLOR_CACHE,
        -:  257:            NULL);
    #####:  258:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  259:   }
        6:  260:   if(mask[DIRTY]=='1'){
    #####:  261:      column = gtk_tree_view_column_new_with_attributes("dirty",
        -:  262:            gtk_cell_renderer_text_new(),
        -:  263:            "text", DIRTY,
        -:  264:            "background", COLOR_CACHE,
        -:  265:            NULL);
    #####:  266:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  267:   }
        6:  268:   if(mask[LAST_ACCESSED]=='1'){
    #####:  269:      column = gtk_tree_view_column_new_with_attributes("last accessed",
        -:  270:            gtk_cell_renderer_text_new(),
        -:  271:            "text", LAST_ACCESSED,
        -:  272:            "background", COLOR_CACHE,
        -:  273:            NULL);
    #####:  274:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  275:   }
        6:  276:   if(mask[TIMES_ACCESSED]=='1'){
    #####:  277:      column = gtk_tree_view_column_new_with_attributes("times accessed",
        -:  278:            gtk_cell_renderer_text_new(),
        -:  279:            "text", TIMES_ACCESSED,
        -:  280:            "background", COLOR_CACHE,
        -:  281:            NULL);
    #####:  282:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  283:   }
        6:  284:   if(mask[TAG]=='1'){
        6:  285:      column = gtk_tree_view_column_new_with_attributes("Tag",
        -:  286:            gtk_cell_renderer_text_new(),
        -:  287:            "text", TAG,
        -:  288:            "background", COLOR_CACHE,
        -:  289:            NULL);
        6:  290:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  291:   }
        6:  292:   if(mask[CONTENT_CACHE]=='1'){
        6:  293:      column = gtk_tree_view_column_new_with_attributes("Content",
        -:  294:            gtk_cell_renderer_text_new(),
        -:  295:            "text", CONTENT_CACHE,
        -:  296:            "background", COLOR_CACHE,
        -:  297:            NULL);
        6:  298:      gtk_tree_view_append_column(GTK_TREE_VIEW(viewData), column);
        -:  299:   }
        -:  300:   ////////////////////////////////////////////////////////
        6:  301:   GtkWidget *scwin = gtk_scrolled_window_new(NULL, NULL);
        6:  302:   gtk_container_add(GTK_CONTAINER(scwin), viewData);
        6:  303:   gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scwin), GTK_POLICY_AUTOMATIC,
        -:  304:         GTK_POLICY_ALWAYS);
        -:  305:   GtkWidget *label;
        -:  306:   //si no es una cache dividida pongo el titulo y return de la funcion
        6:  307:   if(!caches[level].separated) {
        -:  308:      char cadena[50];
        3:  309:      sprintf(cadena, "CACHE L%d", level+1);
        3:  310:      label =gtk_label_new (cadena);
        3:  311:      gtk_box_pack_start(GTK_BOX(vboxData), label, FALSE, FALSE, 1);
        3:  312:      gtk_box_pack_start(GTK_BOX(vboxData), scwin, TRUE, TRUE, 1);
        3:  313:      cacheLevels[level].modelData=modelData;
        3:  314:      cacheLevelPanels[level].vboxData=vboxData;
        3:  315:      cacheLevelPanels[level].viewData=viewData;
        3:  316:      return;
        -:  317:      //si es dividida lo titulo como cache de data y creo la parte correspondiente a instructions
        -:  318:   } else {
        -:  319:      char cadena[50];
        3:  320:      sprintf(cadena, "CACHE L%d DATOS", level+1);
        3:  321:      label =gtk_label_new (cadena);
        3:  322:      gtk_box_pack_start(GTK_BOX(vboxData), label, FALSE, FALSE, 1);
        3:  323:      gtk_box_pack_start(GTK_BOX(vboxData), scwin, TRUE, TRUE, 1);
        3:  324:      cacheLevels[level].modelData=modelData;
        3:  325:      cacheLevelPanels[level].vboxData=vboxData;
        3:  326:      cacheLevelPanels[level].viewData=viewData;
        -:  327:      GtkTreeIter   iterInstruction;
        -:  328:      GtkTreeViewColumn* columnInstruction;
        -:  329:      GtkListStore *modelInstruction;
        -:  330:      GtkWidget *vboxInstruction;
        -:  331:      GtkWidget *viewInstruction;
        3:  332:      vboxInstruction = gtk_vbox_new(FALSE, 2);
        3:  333:      int numLines=caches[level].size/caches[level].line_size;
        3:  334:      int asociativity=caches[level].asociativity;
        3:  335:      modelInstruction=cacheLevels[level].modelInstruction;
        3:  336:      viewInstruction = gtk_tree_view_new_with_model(GTK_TREE_MODEL(modelInstruction));
        3:  337:      GtkTreeSelection * selectionInstruction= gtk_tree_view_get_selection (GTK_TREE_VIEW(viewInstruction));
        3:  338:      gtk_tree_selection_set_mode (selectionInstruction, GTK_SELECTION_NONE);
        -:  339:      //CREO LAS COLUMNAS A MOSTRAR EN LA TABLA. No confundir con las columnas de la estructura de dados model
        3:  340:      if(mask[LINE]=='1'){
        3:  341:         columnInstruction = gtk_tree_view_column_new_with_attributes("Line",
        -:  342:               gtk_cell_renderer_text_new(),
        -:  343:               "text", LINE,
        -:  344:               "background", COLOR_CACHE,
        -:  345:               NULL);
        3:  346:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  347:      }
        3:  348:      if(mask[SET]=='1'){
        3:  349:         columnInstruction = gtk_tree_view_column_new_with_attributes("Set",
        -:  350:               gtk_cell_renderer_text_new(),
        -:  351:               "text", SET,
        -:  352:               "background", COLOR_CACHE,
        -:  353:               NULL);
        3:  354:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  355:      }
        3:  356:      if(mask[VALID]=='1'){
    #####:  357:         columnInstruction = gtk_tree_view_column_new_with_attributes("valid",
        -:  358:               gtk_cell_renderer_text_new(),
        -:  359:               "text", VALID,
        -:  360:               "background", COLOR_CACHE,
        -:  361:               NULL);
    #####:  362:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  363:      }
        3:  364:      if(mask[DIRTY]=='1'){
    #####:  365:         columnInstruction = gtk_tree_view_column_new_with_attributes("dirty",
        -:  366:               gtk_cell_renderer_text_new(),
        -:  367:               "text", DIRTY,
        -:  368:               "background", COLOR_CACHE,
        -:  369:               NULL);
    #####:  370:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  371:      }
        3:  372:      if(mask[LAST_ACCESSED]=='1'){
    #####:  373:         columnInstruction = gtk_tree_view_column_new_with_attributes("last accessed",
        -:  374:               gtk_cell_renderer_text_new(),
        -:  375:               "text", LAST_ACCESSED,
        -:  376:               "background", COLOR_CACHE,
        -:  377:               NULL);
    #####:  378:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  379:      }
        3:  380:      if(mask[TIMES_ACCESSED]=='1'){
    #####:  381:         columnInstruction = gtk_tree_view_column_new_with_attributes("times accessed",
        -:  382:               gtk_cell_renderer_text_new(),
        -:  383:               "text", TIMES_ACCESSED,
        -:  384:               "background", COLOR_CACHE,
        -:  385:               NULL);
    #####:  386:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  387:      }
        3:  388:      if(mask[TAG]=='1'){
        3:  389:         columnInstruction = gtk_tree_view_column_new_with_attributes("Tag",
        -:  390:               gtk_cell_renderer_text_new(),
        -:  391:               "text", TAG,
        -:  392:               "background", COLOR_CACHE,
        -:  393:               NULL);
        3:  394:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  395:      }
        3:  396:      if(mask[CONTENT_CACHE]=='1'){
        3:  397:         columnInstruction = gtk_tree_view_column_new_with_attributes("Content",
        -:  398:               gtk_cell_renderer_text_new(),
        -:  399:               "text", CONTENT_CACHE,
        -:  400:               "background", COLOR_CACHE,
        -:  401:               NULL);
        3:  402:         gtk_tree_view_append_column(GTK_TREE_VIEW(viewInstruction), columnInstruction);
        -:  403:      }
        -:  404:      ///////////////////////////////////////////////////
        3:  405:      GtkWidget *scwinInstruction = gtk_scrolled_window_new(NULL, NULL);
        3:  406:      gtk_container_add(GTK_CONTAINER(scwinInstruction), viewInstruction);
        3:  407:      gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scwinInstruction), GTK_POLICY_AUTOMATIC,
        -:  408:            GTK_POLICY_ALWAYS);
        -:  409:      GtkWidget *labelInstruction;
        -:  410:      char cadenaInstructions[50];
        3:  411:      sprintf(cadenaInstructions, "CACHE L%d INSTRUCCIONES", level+1);
        3:  412:      labelInstruction =gtk_label_new (cadenaInstructions);
        3:  413:      gtk_box_pack_start(GTK_BOX(vboxInstruction), labelInstruction, FALSE, FALSE, 1);
        3:  414:      gtk_box_pack_start(GTK_BOX(vboxInstruction), scwinInstruction, TRUE, TRUE, 1);
        3:  415:      cacheLevels[level].modelInstruction=modelInstruction;
        3:  416:      cacheLevelPanels[level].vboxInstruction=vboxInstruction;
        3:  417:      cacheLevelPanels[level].viewInstruction=viewInstruction;
        3:  418:      return;
        -:  419:   }
        -:  420:}
        -:  421:
        -:  422:/**
        -:  423: * Function to create statistic panel in the gui. The statistics data structure must ghave been created previously.
        -:  424: */
        3:  425:GtkWidget *create_view_statistics(void) {
        -:  426:   GtkTreeViewColumn   *col;
        -:  427:   GtkCellRenderer     *renderer;
        3:  428:   GtkTreeModel *model= estatistics_model;
        3:  429:   GtkWidget *view=     estatistics_view;
        3:  430:   view = gtk_tree_view_new();
        -:  431:   /* --- Column #1 --- */
        3:  432:   col = gtk_tree_view_column_new();
        3:  433:   gtk_tree_view_column_set_title(col, "First Name");
        -:  434:   /* pack tree view column into tree view */
        3:  435:   gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);
        3:  436:   renderer = gtk_cell_renderer_text_new();
        -:  437:   /* pack cell renderer into tree view column */
        3:  438:   gtk_tree_view_column_pack_start(col, renderer, TRUE);
        -:  439:   /* connect 'text' property of the cell renderer to
        -:  440:    *  model column that contains the first name */
        3:  441:   gtk_tree_view_column_add_attribute(col, renderer, "text", COMPONET_OR_PROPERTY);
        -:  442:   /* --- Column #2 --- */
        3:  443:   col = gtk_tree_view_column_new();
        3:  444:   gtk_tree_view_column_set_title(col, "Last Name");
        -:  445:   /* pack tree view column into tree view */
        3:  446:   gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);
        3:  447:   renderer = gtk_cell_renderer_text_new();
        -:  448:   /* pack cell renderer into tree view column */
        3:  449:   gtk_tree_view_column_pack_start(col, renderer, TRUE);
        -:  450:   /* connect 'text' property of the cell renderer to
        -:  451:    *  model column that contains the last name */
        3:  452:   gtk_tree_view_column_add_attribute(col, renderer, "text", VALUE);
        -:  453:   /* set 'weight' property of the cell renderer to
        -:  454:    *  bold print (we want all last names in bold) */
        3:  455:   g_object_set(renderer,
        -:  456:         "weight", PANGO_WEIGHT_BOLD,
        -:  457:         "weight-set", TRUE,
        -:  458:         NULL);
        3:  459:   gtk_tree_view_set_model(GTK_TREE_VIEW(view), model);
        3:  460:   gtk_tree_view_set_headers_visible (GTK_TREE_VIEW(view),0);
        3:  461:   g_object_unref(model); /* destroy model automatically with view */
        3:  462:   gtk_tree_selection_set_mode(gtk_tree_view_get_selection(GTK_TREE_VIEW(view)),
        -:  463:         GTK_SELECTION_NONE);
        3:  464:   estatistics_view= view;
        3:  465:   return view;
        -:  466:}
        -:  467:
        -:  468:/**
        -:  469: * This function inserts text into the panel (actually it is being inserted into the buffer).
        -:  470: * @param text to be added
        -:  471: */
    #####:  472:void insertTextInPanel(char* text) {
        -:  473:   GtkTextBuffer *buffer;
        -:  474:   GtkTextMark *mark;
        -:  475:   GtkTextIter iter;
    #####:  476:   buffer =gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_view));
    #####:  477:   mark = gtk_text_buffer_get_insert (buffer);
    #####:  478:   gtk_text_buffer_get_iter_at_mark (buffer, &iter, mark);
        -:  479:   /* Insert newline (only if there's already text in the buffer). */
        -:  480:   //if (gtk_text_buffer_get_char_count(buffer))
        -:  481:   //gtk_text_buffer_insert (buffer, &iter, "\n", 1);
    #####:  482:   gtk_text_buffer_insert (buffer, &iter, text, -1);
    #####:  483:}
        -:  484:
        -:  485:/**
        -:  486: * Function for scrolling the panel to a text line
        -:  487: * @param line which the panel will be scrolled to.
        -:  488: */
        3:  489:void scrollTextViewToLine(long line) {
        -:  490:   GtkTextIter iter;
        3:  491:   gtk_text_buffer_get_iter_at_line (buffer,
        -:  492:         &iter,
        -:  493:         line);
        -:  494:   //scroll hasta que la nueva line es visible
        3:  495:   gtk_text_view_scroll_to_iter (GTK_TEXT_VIEW(text_view), &iter, 0.0, 0, 0.0, 0.0);
        3:  496:   return;
        -:  497:}
        -:  498:
        -:  499:/**
        -:  500: * Function for scrolling the memory panel to an address
        -:  501: * @param address which the memory panel will be scrolled to.
        -:  502: */
        6:  503:int scrollMemoryToPos(long address) {
        -:  504:   char rowChar[50];
        -:  505:   //if not word address return error
        6:  506:   if(address%(cpu.word_width/8)!=0){
    #####:  507:      return -1;
        -:  508:   }
        -:  509:   //if out of page return error
        6:  510:   if(address<memory.page_base_address || address>(memory.page_base_address+memory.page_size)){
        3:  511:      return -2;
        -:  512:   }
        -:  513:   //get the table row from the memory address
        3:  514:   long i=(address-memory.page_base_address)/(cpu.word_width/8);  
        3:  515:   sprintf(rowChar, "%ld", i);
        3:  516:   GtkTreePath * path=gtk_tree_path_new_from_string (rowChar);
        3:  517:   gtk_tree_view_scroll_to_cell (GTK_TREE_VIEW(viewMEMORY),
        -:  518:         path, NULL, TRUE, 0.5, 0);
        3:  519:   return 0;
        -:  520:}
        -:  521:
        -:  522:/**
        -:  523: * Function for scrolling the cache panel to a row
        -:  524: * @param level which will be scrolled.
        -:  525: * @param row cache line which the cache panel will be scrolled to.
        -:  526: */
        3:  527:void scrollCacheToRow(int level, long row) {
        3:  528:   scrollDataCacheToRow(level, row);
        3:  529:}
        -:  530:
        -:  531:/**
        -:  532: * Function for scrolling the data cache panel to a row
        -:  533: * @param level which will be scrolled.
        -:  534: * @param row cache line which the data cache panel will be scrolled to.
        -:  535: */
        6:  536:void scrollDataCacheToRow(int level, long row) {
        -:  537:   char rowChar[50];
        6:  538:   sprintf(rowChar, "%ld", row);
        6:  539:   GtkTreePath * path=gtk_tree_path_new_from_string (rowChar);
        6:  540:   gtk_tree_view_scroll_to_cell (GTK_TREE_VIEW(cacheLevelPanels[level].viewData),
        -:  541:         path, NULL, TRUE, 0.5, 0);
        6:  542:}
        -:  543:
        -:  544:/**
        -:  545: * Function for scrolling the instruction cache panel to a row
        -:  546: * @param level which will be scrolled.
        -:  547: * @param row cache line which the instruction cache panel will be scrolled to.
        -:  548: */
        3:  549:void scrollInstructionCacheToRow(int level, long row) {
        -:  550:   char rowChar[50];
        3:  551:   sprintf(rowChar, "%ld", row);
        3:  552:   GtkTreePath * path=gtk_tree_path_new_from_string (rowChar);
        3:  553:   gtk_tree_view_scroll_to_cell (GTK_TREE_VIEW(cacheLevelPanels[level].viewInstruction),
        -:  554:         path, NULL, TRUE, 0.5, 0);
        3:  555:}
