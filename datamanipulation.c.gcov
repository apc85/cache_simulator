        -:    0:Source:datamanipulation.c
        -:    0:Graph:datamanipulation.gcno
        -:    0:Data:datamanipulation.gcda
        -:    0:Runs:7
        -:    0:Programs:1
        -:    1:ï»¿#include <stdio.h>
        -:    2:#include <string.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <ctype.h>
        -:    5:#include <math.h>
        -:    6:
        -:    7:#include "datamanipulation.h"
        -:    8:
        -:    9:/*
        -:   10: * convert string into long. It can have a multiplier G for 10^9, M for 10^6 o K for 10^3. Any other char will result in error.
        -:   11: * @param  String to be converted into long
        -:   12: * @return long with converted value or error. -1 for wrong value error. -2 for null pointer error.
        -:   13: */
        4:   14:long parseLongK1000(const char * cadena) {
        -:   15:
        4:   16:    if(cadena==NULL) {
    #####:   17:        return -2;
        -:   18:    }
        -:   19:    // Obtain the multiplier k, M, or G. Else error
        4:   20:    long len=strlen(cadena);
        4:   21:    long multiplicador=1;
        4:   22:    if(cadena[len-1]=='K'||cadena[len-1]=='k') {
    #####:   23:        multiplicador=1000;
        4:   24:    } else if(cadena[len-1]=='M'||cadena[len-1]=='m') {
    #####:   25:        multiplicador=1000000;
        4:   26:    } else if(cadena[len-1]=='G'||cadena[len-1]=='g') {
        4:   27:        multiplicador=1000000000;
    #####:   28:    } else if(cadena[len-1]>'9'||cadena[len-1]<'0') {
    #####:   29:        return -1;
        -:   30:
        -:   31:    }
        -:   32:
        -:   33:    // if something not numeric or multiplier. error return -1
        8:   34:    for(long i=0; i<len-1; i++) {
        -:   35:
        4:   36:        if(cadena[i]>'9'||cadena[i]<'0') {
    #####:   37:            return -1;
        -:   38:        }
        -:   39:    }
        -:   40:
        4:   41:    if(len==1){
    #####:   42:         return multiplicador;
        -:   43:
        -:   44:    }
        -:   45:
        4:   46:    return atoi(cadena)*multiplicador;
        -:   47:}
        -:   48:
        -:   49:/*
        -:   50: * Convert string into long. It can have a multiplier G for 2^30, M for 2^20 o K for 2^10. Any othe char will result in error.
        -:   51: * @param  String to be converted into long
        -:   52: * @return long with converted value or error. -1 for wrong value error. -2 for null pointer error.
        -:   53: */
       24:   54:long parseLongK1024(const char * cadena) {
        -:   55:
       24:   56:    if(cadena==NULL) {
    #####:   57:        return -2;
        -:   58:    }
        -:   59:
        -:   60:    // Obtain the multiplier k, M, or G. Else error
       24:   61:    long len=strlen(cadena);
       24:   62:    long multiplicador=1;
       24:   63:    if(cadena[len-1]=='K'||cadena[len-1]=='k') {
       12:   64:        multiplicador=1024;
       12:   65:    } else if(cadena[len-1]=='M'||cadena[len-1]=='m') {
        4:   66:        multiplicador=1048576;
        8:   67:    } else if(cadena[len-1]=='G'||cadena[len-1]=='g') {
    #####:   68:        multiplicador=1073741824;
        8:   69:    } else if(cadena[len-1]>'9'||cadena[len-1]<'0') {
    #####:   70:        return -1;
        -:   71:
        -:   72:    }
        -:   73:
        -:   74:    // if something not numeric or multiplier. error return -1
       52:   75:    for(long i=0; i<len-1; i++) {
        -:   76:
       28:   77:        if(cadena[i]>'9'||cadena[i]<'0') {
    #####:   78:            return -1;
        -:   79:        }
        -:   80:    }
        -:   81:
       24:   82:    if(len==1){
    #####:   83:         return multiplicador;
        -:   84:
        -:   85:    }
        -:   86:
       24:   87:    return atoi(cadena)*multiplicador;
        -:   88:}
        -:   89:
        -:   90:/*
        -:   91: * convert string into int.
        -:   92: * @param  String to be converted into int
        -:   93: * @return int with converted value or error. -1 for wrong value error. -2 for null pointer error.
        -:   94: */
       12:   95:int parseInt(const char * cadena) {
        -:   96:
       12:   97:    if(cadena==NULL) {
    #####:   98:        return -2;
        -:   99:    }
        -:  100:    // Obtain the multiplier k, M, or G. Else error.
       12:  101:    int len=strlen(cadena);
        -:  102:
        -:  103:    // if something not numeric or multiplier. error return -1
       32:  104:    for(long i=0; i<len; i++) {
        -:  105:
       20:  106:        if(cadena[i]>'9'||cadena[i]<'0') {
    #####:  107:            return -1;
        -:  108:        }
        -:  109:    }
        -:  110:
       12:  111:    return atoi(cadena);
        -:  112:}
        -:  113:
        -:  114:/*
        -:  115: * Convert string into boolean.
        -:  116: * @param  String to be converted into boolean. Possible strings: yes, no, true, false, 0, 1
        -:  117: * @return int with converted value. 1 for true, 0 for false, -1 for wrong value error. -2 for null pointer error.
        -:  118: */
        8:  119:int parseBoolean(const char * cadena) {
        -:  120:
        -:  121:    // if null return error -2
        8:  122:    if(cadena==NULL) {
    #####:  123:        return -2;
        -:  124:    }
        -:  125:
        -:  126:    // turn into lower case
        -:  127:    char cadenaMin[10];
        -:  128:    int i;
       20:  129:    for( i= 0; cadena[i]; i++) {
       12:  130:        cadenaMin[i] = tolower(cadena[i]);
        -:  131:    }
        8:  132:    cadenaMin[i]='\0';
        -:  133:
        -:  134:
        -:  135:
        -:  136:    // check string content and retun equivalent boolean value.
       20:  137:    for(int i=0; i<N_TRUES; i++) {
       16:  138:        if(strcmp(str_true[i], cadenaMin)==0) {
        4:  139:            return 1;
        -:  140:        }
        -:  141:
        -:  142:    }
        -:  143:
        8:  144:    for(int i=0; i<N_FALSES; i++) {
        8:  145:        if(strcmp(str_false[i], cadenaMin)==0) {
        4:  146:            return 0;
        -:  147:        }
        -:  148:
        -:  149:    }
        -:  150:
    #####:  151:    return -1;
        -:  152:
        -:  153:
        -:  154:}
        -:  155:
        -:  156:/*
        -:  157: * Convert string into enum which represent replacement policy.
        -:  158: * @param  String to be converted into enum. Possible strings defined in str_replacementPolicy
        -:  159: * @return enum  value or error. -2 for null pointer. -1 for wrong value error
        -:  160: */
        8:  161:int parseReplacementPolicy(const char * cadena) {
        8:  162:    if(cadena==NULL) {
    #####:  163:        return -2;
        -:  164:    }
        8:  165:    for(int i=0; i<N_REPLACEMENT; i++) {
        8:  166:        if(strcmp(cadena, str_replacementPolicy[i])==0) {
        8:  167:            return i;
        -:  168:        }
        -:  169:    }
    #####:  170:    return -1;
        -:  171:}
        -:  172:
        -:  173:/*
        -:  174: * Convert string into enum which represent write policy.
        -:  175: * @param  String to be converted into enum. Possible strings defined in str_replacementPolicy
        -:  176: * @return enum  value or error. -2 for null pointer error. -1 for wrong value error
        -:  177: */
        8:  178:int parseWritePolicy(const char * cadena) {
        -:  179:
        -:  180:    // if null pointer retun error -2
        8:  181:    if(cadena==NULL) {
    #####:  182:        return -2;
        -:  183:    }
        -:  184:
       12:  185:    for(int i=0; i<N_WRITE; i++) {
       12:  186:        if(strcmp(cadena, str_writePolicy[i])==0) {
        8:  187:            return i;
        -:  188:        }
        -:  189:    }
        -:  190:
    #####:  191:    return -1;
        -:  192:
        -:  193:}
        -:  194:
        -:  195:/*
        -:  196: * Check if a number is power of 2
        -:  197: * @param number to check
        -:  198: * @return boolean
        -:  199: */
      155:  200:int isPowerOf2(long number) {
        -:  201:
      155:  202:    return number && !(number & (number - 1));
        -:  203:
        -:  204:}
        -:  205:
        -:  206:/*
        -:  207: * Check if a number is a multiple of 8
        -:  208: * @param number to check
        -:  209: * @return boolean
        -:  210: */
    #####:  211:int isAMultipleOf8(long number) {
        -:  212:
    #####:  213:    return !number%8;
        -:  214:
        -:  215:}
        -:  216:
        -:  217:/*
        -:  218: * Checks if a string has binary value inside.
        -:  219: * @param  cadena String to be checked
        -:  220: * @return 1 if it is binary. -1 if it is not binary. -2 if NULL char* param
        -:  221: */
        8:  222:int isCorrectBinary(const char * cadena) {
        -:  223:
        -:  224:    // if null return error -2
        8:  225:    if(cadena==NULL) {
    #####:  226:        return -2;
        -:  227:    }
        -:  228:    
       72:  229:    for(int i= 0; cadena[i]; i++) {
       64:  230:        if(cadena[i]!='0'&&cadena[i]!='1'){
    #####:  231:        	return -1;
        -:  232:	}
        -:  233:    }
        8:  234:    return 1;
        -:  235:}
        -:  236:
        -:  237:/*
        -:  238: * convert string into double. It can have a multiplier p for 1e-12, n for 1e-9, u for 1e-6, m for 1e-3. Other char will result in error.
        -:  239: * @param  String to be converted into double
        -:  240: * @return long with converted value or error. -1 for wrong value error. -2 for null pointer error.
        -:  241: */
       16:  242:double parseDouble(const char * cadena) {
        -:  243:
       16:  244:    if(cadena==NULL) {
    #####:  245:        return -2;
        -:  246:    }
        -:  247:    // Obtain the multiplier p, n, u, or m. Else error
       16:  248:    long len=strlen(cadena);
       16:  249:    double multiplicador=1;
       16:  250:    if(cadena[len-1]=='m') {
        4:  251:        multiplicador=1.0/1000.0;
       12:  252:    } else if(cadena[len-1]=='u') {
    #####:  253:        multiplicador=1.0/1000000.0;
       12:  254:    } else if(cadena[len-1]=='n') {
        4:  255:        multiplicador=1.0/1000000000.0;
        8:  256:    } else if(cadena[len-1]=='p') {
    #####:  257:        multiplicador=1.0/1000000000000.0;
        8:  258:    } else if(cadena[len-1]>'9'||cadena[len-1]<'0') {
    #####:  259:        return -1;
        -:  260:
        -:  261:    }
        -:  262:
        -:  263:    // if something not numeric or multiplier. error return -1
       32:  264:    for(long i=0; i<len-1; i++) {
        -:  265:
       16:  266:        if(cadena[i]>'9'||cadena[i]<'0') {
    #####:  267:            return -1;
        -:  268:        }
        -:  269:    }
        -:  270:
       16:  271:    return atoi(cadena)*multiplicador;
        -:  272:}
        -:  273:
        -:  274:/*
        -:  275: * convert string hex address into long. It can have a the format 0x...... 
        -:  276: * Other char will result in error.
        -:  277: * @param  page_base_address to be converted into long
        -:  278: * @return long with converted value or error. -1 for wrong value error. -2 for null pointer error.
        -:  279: */
        4:  280:long parseAddress(const char* page_base_address){
        -:  281:
        4:  282:        if(page_base_address==NULL){
    #####:  283:		return -2;
        -:  284:	}
        -:  285:
        4:  286:        long toReturn= strtol(page_base_address, NULL, 16);
        4:  287:	return toReturn;
        -:  288:        // provisional TODO
        -:  289:	//faltan comprobaciones sobre tamano y rango de la direccion
        -:  290:}
        -:  291:
        -:  292:/**
        -:  293: * function for checking if hex format is correct
        -:  294: * @param number hex number with string format to be checked
        -:  295: */
      216:  296:int isCorrectHexadecimal(char * number){
      216:  297:   if(strlen(number)<2){
    #####:  298:      return 0;
        -:  299:   }
      216:  300:   if(number[0]!='0'){
    #####:  301:      return 0;
        -:  302:   }
      216:  303:   if(number[1]!='x'&&number[1]!='X'){
    #####:  304:      return 0;
        -:  305:   }
        -:  306:
     1944:  307:   for(int i=2; i<strlen(number); i++){
     1728:  308:      if(number[i]<'0'||(number[i]>'9'&&number[i]<'A')||(number[i]>'F'&&number[i]<'a')||number[i]>'f'){
    #####:  309:         return 0;
        -:  310:      }
        -:  311:   }
      216:  312:   return 1;
        -:  313:}
        -:  314:
        -:  315:/*
        -:  316: * function for checking if dec format is correct
        -:  317: * @param number dec number with string format to be checked
        -:  318: */
      162:  319:int isCorrectDecimal(char * number){
      540:  320:   for(int i=0; number[i]!='\0'; i++){
      378:  321:      if(number[i]<'0'||number[i]>'9'){
    #####:  322:         return 0;
        -:  323:      }
        -:  324:   }
      162:  325:   return 1;
        -:  326:}
        -:  327:
        -:  328:
        -:  329:/*
        -:  330: * Convert an array of integers to a string
        -:  331: */
     1332:  332:void contentArrayToString(long* array, char* content, int count, int width){
        -:  333:   char num[50];
     1332:  334:   content[0]='\0';        
    22644:  335:   for(int i=0; i<count; i++) {
    21312:  336:      sprintf(num, "%s%0*lx", i>0 ? " " : "", width, array[i]);
    21312:  337:      strcat(content, num);
        -:  338:   }
     1332:  339:}
        -:  340:
        -:  341:/*
        -:  342: * Convert a space separated string of hex numbers into an array of longs
        -:  343: */
       14:  344:void contentStringToArray(long* array, char* content, int count){
        -:  345:   char *pch;
       14:  346:   pch = strtok (content," ");
      238:  347:   for(int i=0; pch != NULL || i < count; i++, pch = strtok (NULL, " ")) {
      224:  348:      array[i] = strtol(pch, NULL, 16);
        -:  349:   }
       14:  350:}
        -:  351:
        -:  352:
        -:  353:
        -:  354:/*void contentArrayToString(long* array, char* content, int count, int width){
        -:  355:
        -:  356:        content[0]='\0';        
        -:  357:
        -:  358:        for(int i=0; i<count; i++){
        -:  359:
        -:  360:          char num[50];
        -:  361:          sprintf(num, "%0*lx", width, array[i]);
        -:  362:	  strcat(content, num);
        -:  363:          strcat(content, " ");
        -:  364:	}
        -:  365:}*/
        -:  366:
        -:  367:/*
        -:  368:void contentStringToArray(long* array, char* content, int count){
        -:  369:        
        -:  370:
        -:  371:	for(int i=0; i<count; i++){
        -:  372:		array[i]=0;
        -:  373:	}
        -:  374:
        -:  375:        int len=strlen(content);
        -:  376:        int lineIndex=0;
        -:  377:        char num[100];
        -:  378:	int j=0;
        -:  379:        for(int i=0; i<len; i++){
        -:  380:	     if(content[i]!=' '){
        -:  381:                  num[j]=toupper(content[i]);
        -:  382:             	  j++;
        -:  383:             }else{
        -:  384:	          j=0;
        -:  385:		  array[lineIndex]=strtol(num, NULL, 16);
        -:  386:         	  num[0]='\0';
        -:  387:        	  lineIndex++;
        -:  388:             }
        -:  389:
        -:  390:        }
        -:  391:}*/
        -:  392:
