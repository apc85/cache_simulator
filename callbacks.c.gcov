        -:    0:Source:callbacks.c
        -:    0:Graph:callbacks.gcno
        -:    0:Data:callbacks.gcda
        -:    0:Runs:7
        -:    0:Programs:1
        -:    1:#include "callbacks.h"
        -:    2:#include "datainterface.h"
        -:    3:#include "traceparser.h"
        -:    4:#include "simulator.h"
        -:    5:
        -:    6://CALLBACKS//////////////////////////////////////////////////////////////
        -:    7:
        -:    8:
        -:    9:/**
        -:   10: * Callback function for setting simulation to its initial state.
        -:   11: */
        8:   12:void callbackRestart( GtkWidget *widget, gpointer   data){
        -:   13:   // Reset each cache
       24:   14:   for(int i=0; i<numberCaches; i++){
        -:   15:      // If it is a divided cache, both parts must be reset
       16:   16:      if(caches[i].separated){
        8:   17:         resetDataCache(i);
        8:   18:         resetInstructionCache(i);
        -:   19:      } else {
        8:   20:         resetCache(i);
        -:   21:      }
        -:   22:   }
        8:   23:   resetMemory();
        -:   24:
        -:   25:   // Go to the first line in the trace panel */
        -:   26:   GtkTextIter lineIterCurrent;
        8:   27:   gtk_text_buffer_get_iter_at_mark (buffer, &lineIterCurrent, marcaLineCurrent);
        -:   28:   GtkTextIter start;
        8:   29:   gtk_text_buffer_get_iter_at_offset (buffer, &start, 0);
        8:   30:   GtkTextIter end=lineIterCurrent;
        8:   31:   GtkTextIter lineIterSiguiente=lineIterCurrent;
        8:   32:   gtk_text_view_forward_display_line (GTK_TEXT_VIEW(text_view), &lineIterSiguiente);
        -:   33:   // Remove all tags for removing colour.
        8:   34:   gtk_text_buffer_remove_all_tags (buffer,
        -:   35:         &start,
        -:   36:         &end);
        8:   37:   gtk_text_buffer_get_iter_at_offset (buffer, &lineIterInicial, 0);
        8:   38:   marcaLineCurrent= gtk_text_mark_new (NULL, 1);
        8:   39:   gtk_text_buffer_add_mark (buffer,
        -:   40:         marcaLineCurrent,
        -:   41:         &lineIterInicial);
        -:   42:   // Scroll each panel to first line
        8:   43:   scrollMemoryToPos(0);
        8:   44:   scrollTextViewToLine(0);
       24:   45:   for(int i=0; i<numberCaches; i++){
       16:   46:      if(caches[i].separated){
        8:   47:         scrollDataCacheToRow(i, 0);
        8:   48:         scrollInstructionCacheToRow(i, 0);
        -:   49:      }else{
        8:   50:         scrollCacheToRow(i, 0);
        -:   51:      }
        -:   52:   }
        8:   53:}
        -:   54:
        -:   55:/**
        -:   56: * Callback fuction to perform the complete simulation
        -:   57: */
       12:   58:void callbackSimulateAll( GtkWidget *widget, gpointer   data)
        -:   59:{
        -:   60:   char *currentLine;
      173:   61:   while(currentLine = nextLineTrace()) {
      149:   62:      if(preprocessTraceLine(currentLine)) {
        -:   63:         struct memOperation operation;
      113:   64:         parseLine(currentLine, -1, &operation);
      113:   65:         simulate_step(&operation);
        -:   66:      }
        -:   67:   }
       12:   68:}
        -:   69:
        -:   70:/**
        -:   71: * Callback fuction for advancing one step on simulation 
        -:   72: */
       17:   73:void callbackNextStep( GtkWidget *widget, gpointer   data)
        -:   74:{
       17:   75:   char *currentLine = nextLineTrace();
       17:   76:   if(currentLine!=NULL&&preprocessTraceLine(currentLine)) {
        -:   77:      struct memOperation operation;
        7:   78:      parseLine(currentLine, -1, &operation);
        7:   79:      simulate_step(&operation);
        -:   80:   }
        -:   81:
       17:   82:}
        -:   83:
        -:   84:
        -:   85:#if DEBUG
        -:   86:/**
        -:   87: * Callback fuction for testing the program. Only in debug mode
        -:   88: */
        7:   89:void callbackTest( GtkWidget *widget, gpointer   data){
        -:   90:
        -:   91:   //////pruebas
        7:   92:   setStatistics("Cache L2", "Fault rate", "tres");
        7:   93:   setStatistics("CPU", "Fault rate", "tres");
        7:   94:   setStatistics("Cache L3", "nueva categoria", "cuatro");
        7:   95:   setStatistics("Cache NUEVA", "nueva categoria2", "cuatro2");
        -:   96:   char *value;
        7:   97:   value=getStatistics("Cache L1", "Fault rate");
        -:   98:   //printf("valor: %s\n", value);
        7:   99:   value=getStatistics("Cache NUEVA", "nueva categoria2");
        -:  100:   //printf("valor: %s\n", value);
        7:  101:   value=getStatistics("Cache NUEVA", "ia2");
        -:  102:   //printf("valor: %s\n", value);
        7:  103:   value=getStatistics("CaUEVA", "ia2");
        -:  104:   //printf("valor: %s\n", value);
        -:  105:   struct memoryPosition pos;
        7:  106:   pos.address=256;
        7:  107:   pos.content=1024;
        7:  108:   char cadena[]="hola mundo. Este es el contenido del usuario.";
        7:  109:   pos.user_content=cadena;
        7:  110:   writePosicionMemory(&pos, 134217732);
        -:  111:   //showPosicionMemory(9);
        -:  112:   //showPosicionMemory(10);
        -:  113:   //showPosicionMemory(11);
        -:  114:   struct cacheLine line;
        7:  115:   line.tag=2;
        7:  116:   line.line=1;
        7:  117:   line.set=4;
        7:  118:   line.user_content="hola mundo. Este es el contenido del usuario en la linea cache.";
        7:  119:   line.dirty=2;
        7:  120:   line.valid=1;
        7:  121:   line.last_accessed=3;
        7:  122:   line.times_accessed=4;
        7:  123:   line.content=(long[]){1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
        -:  124:   void * user_use;
        -:  125:   //writeLineCacheInstructions(0, &line, 7);
        7:  126:   line.content=(long[]){1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
        7:  127:   writeLineCacheData(0, &line, 7);
        7:  128:   line.content=(long[]){1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
        7:  129:   writeLineCache(1, &line, 7);
        7:  130:   showCacheLineInstructions(0, 7);
        7:  131:   showCacheLineData(0, 7);
        -:  132:   //showCacheLine(1, 7);
        -:  133:   //showCacheLine(1, 6);
        7:  134:   setColorMemoryPosition(134217732, 5);
        7:  135:   setColorDataCacheLine(0, 2, 9);
        7:  136:   setColorInstructionsCacheLine(0, 2, 10);
        -:  137:   //setColorInstructionsCacheLine(0, 2, 11);
        7:  138:   setColorCacheLine(1, 2, 5);
        -:  139:   //free((line).content);
        7:  140:   scrollMemoryToPos(134217832);
        -:  141:   //scrollMemoryToPos(518);
        -:  142:   //scrollDataCacheToRow(0, 32);
        -:  143:   //scrollInstructionCacheToRow(0, 32);
        -:  144:   //scrollCacheToRow(1, 32);
        -:  145:
        7:  146:}
        -:  147:#endif
        -:  148:
        -:  149:
        -:  150:/* Destroy callback. This is used when you close the program*/
        2:  151:void destroy( GtkWidget *widget, gpointer   data )
        -:  152:{
        2:  153:   gtk_main_quit ();
        2:  154:}
        -:  155:
        -:  156:/* Delete_event callback. This is used when you close the program*/
        2:  157:gint delete_event( GtkWidget *widget,
        -:  158:      GdkEvent  *event,
        -:  159:      gpointer   data )
        -:  160:{
        -:  161:   /* If you return FALSE in the "delete_event" signal handler,
        -:  162:    * GTK will emit the "destroy" signal. Returning TRUE means
        -:  163:    * you don't want the window to be destroyed.
        -:  164:    * This is useful for popping up 'are you sure you want to quit?'
        -:  165:    * type dialogs. */
        -:  166:   //g_print ("fin del programa\n");
        -:  167:   /* Change TRUE to FALSE and the main window will be destroyed with
        -:  168:    * a "delete_event". */
        2:  169:   return FALSE;
        -:  170:}
