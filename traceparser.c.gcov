        -:    0:Source:traceparser.c
        -:    0:Graph:traceparser.gcno
        -:    0:Data:traceparser.gcda
        -:    0:Runs:7
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include "gui.h"
        -:    5:#include "datamanipulation.h"
        -:    6:#include "traceparser.h"
        -:    7:#include "datastore.h"
        -:    8:
        -:    9:struct memOperation* memoryOperations = NULL;
        -:   10:
        -:   11:/**
        -:   12: * Parse a trace line. It receives a string with the trace line and its line number in the trace file.
        -:   13: * It returns by reference a structure with the parsed information.
        -:   14: */
      216:   15:int parseLine(char* line, int lineNumber, struct memOperation *operation){
        -:   16:#if DEBUG
      216:   17:   fprintf(stderr,"Parsing trace line --%s--\n", line);
        -:   18:#endif
        -:   19:   // Set default values for optional fields
      216:   20:   int hasBreakPoint=DEFAULT_HAS_BREAK_POINT;
      216:   21:   int size=DEFAULT_SIZE;
      216:   22:   int data=DEFAULT_DATA;
      216:   23:   int instructionOrData=DEFAULT_INSTRUCTION_OR_DATA;
      216:   24:   int operationType=DEFAULT_OPERATION_TYPE;
      216:   25:   long address=DEFAULT_ADDRESS; 
        -:   26:
        -:   27:
        -:   28:   // Check wether it is a breakpoint line
      216:   29:   if(line[0] == '!') {
       27:   30:      hasBreakPoint = 1;
        -:   31:      // Skip to begining of first field
       27:   32:      line++;
        -:   33:   }
        -:   34:
      216:   35:   int fieldId = 0;
      216:   36:   char * pch = strtok (line," ");
     1242:   37:   while (pch != NULL)
        -:   38:   {
        -:   39:      // Current field
      810:   40:      switch(fieldId) {
        -:   41:         case 0: // Instruction or Data (One character)
      216:   42:            if(strlen(pch) != 1 || ( *pch != 'I' && *pch != 'D')) {
    #####:   43:               fprintf(stderr,"memory operation must be Intruction (I) or Data (D). Line %d\n", lineNumber);
    #####:   44:               return -1;
        -:   45:            }
      216:   46:            instructionOrData = *pch == 'I' ? INSTRUCTION : DATA;
      216:   47:            break;
        -:   48:         case 1: // Address (Must be hexadecimal)
      216:   49:            if(!isCorrectHexadecimal(pch)){
    #####:   50:               fprintf(stderr,"invalid address. line %d\n", lineNumber);
    #####:   51:               return -1;
        -:   52:            }
      216:   53:            address = strtol(pch, NULL, 16);
      216:   54:            break;
        -:   55:         case 2: // Load/Fetch or Store (One character)
      216:   56:            if(strlen(pch) != 1 || ( *pch != 'L' && *pch != 'S')) {
    #####:   57:               fprintf(stderr,"memory operation must be Load/Fetch (L) or Store (S). Line %d\n", lineNumber);
    #####:   58:               return -1;
        -:   59:            }
      216:   60:            operationType = *pch == 'L' ? LOAD : STORE;
      216:   61:            break;
        -:   62:         case 3: // Size (Must be number of bytes and power of two)
      135:   63:            if(!isCorrectDecimal(pch)){
    #####:   64:               fprintf(stderr,"invalid size. Line %d\n", lineNumber);
    #####:   65:               return -1;
        -:   66:            }
      135:   67:            size = atoi(pch);
      135:   68:            if(!isPowerOf2(size)){
    #####:   69:               fprintf(stderr,"size must be power of 2. Line %d\n", lineNumber);
    #####:   70:               return -1;
        -:   71:            }
      135:   72:            break;
        -:   73:         case 4: // Data (Must be a number)
       27:   74:            if(!isCorrectDecimal(pch)){
    #####:   75:               fprintf(stderr,"invalid data. Line %d\n", lineNumber);
    #####:   76:               return -1;					
        -:   77:            }
       27:   78:            data = atoi(pch);
       27:   79:            break;
        -:   80:         default: // Too many fields
    #####:   81:            fprintf(stderr,"too many fields. Line %d\n", lineNumber);
    #####:   82:            return -1;
        -:   83:      }
        -:   84:      // Get next field
      810:   85:      fieldId++;
      810:   86:      pch = strtok (NULL, " ");
        -:   87:   }
      216:   88:   if(fieldId < 3) {
    #####:   89:      fprintf(stderr,"too few fields. Line %d\n", lineNumber);
    #####:   90:      return -1;
        -:   91:   }
        -:   92:
      216:   93:   if(operation!=NULL){
        -:   94:
      168:   95:       operation->hasBreakPoint=hasBreakPoint;
      168:   96:       operation->size=size;
      168:   97:       operation->data=data;
      168:   98:       operation->instructionOrData=instructionOrData;
      168:   99:       operation->operationType=operationType;
      168:  100:       operation->address=address; 
        -:  101:
        -:  102:   }
      216:  103:   return 0;
        -:  104:}
        -:  105:/**
        -:  106: * function for showing all values loaded from tracefile
        -:  107: */
        2:  108:void showOperations(){
        2:  109:   fprintf(stderr,"\n");
       50:  110:   for(int i=0; i<numberOfOperations; i++){
       48:  111:      if(memoryOperations[i].hasBreakPoint){
        6:  112:         fprintf(stderr," ! ");
        6:  113:         if(memoryOperations[i].instructionOrData==INSTRUCTION){
        6:  114:            fprintf(stderr,"I ");
        -:  115:         }
        6:  116:         if(memoryOperations[i].instructionOrData==DATA){
    #####:  117:            fprintf(stderr,"D ");
        -:  118:         }
        -:  119:      }else{
       42:  120:         if(memoryOperations[i].instructionOrData==INSTRUCTION){
       12:  121:            fprintf(stderr,"   I ");
        -:  122:         }
       42:  123:         if(memoryOperations[i].instructionOrData==DATA){
       30:  124:            fprintf(stderr,"   D ");
        -:  125:         }
        -:  126:      }
        -:  127:      char number[20];
       48:  128:      sprintf(number, "0x%lx",memoryOperations[i].address);
       48:  129:      int len= strlen(number);
       48:  130:      int numEspacios=16-len;
       48:  131:      fprintf(stderr," %s ", number);
      354:  132:      for(int j=0; j<numEspacios; j++){
      306:  133:         fprintf(stderr," ");
        -:  134:      }
       48:  135:      if(memoryOperations[i].operationType==LOAD){
       36:  136:         fprintf(stderr," L ");
        -:  137:      }
       48:  138:      if(memoryOperations[i].operationType==STORE){
       12:  139:         fprintf(stderr," S ");
        -:  140:      }
        -:  141:      char number2[20];
       48:  142:      sprintf(number2, " %d ", memoryOperations[i].size);
       48:  143:      len=strlen(number2);
       48:  144:      numEspacios=10-len;
       48:  145:      fprintf(stderr," %s ", number2);
      354:  146:      for(int j=0; j<numEspacios; j++){
      306:  147:         fprintf(stderr," ");
        -:  148:      }
        -:  149:
       48:  150:      fprintf(stderr," %ld ", memoryOperations[i].data);
       48:  151:      fprintf(stderr,"\n");
        -:  152:   }
        2:  153:}
        -:  154:
        -:  155:/** 
        -:  156: * Remove comments and other string operations on a line from a trace file.
        -:  157: * Returns 1 if the line is not empty, after removing the comments.
        -:  158: */
        -:  159:
      288:  160:int preprocessTraceLine(char *currentLine) {
      288:  161:   int emptyLine=1;
     4113:  162:   for(int i=0; currentLine[i]!='\0'; i++){
        -:  163:      // Replace tabs with spaces
     4113:  164:      if(currentLine[i]=='\t'){
    #####:  165:         currentLine[i]=' ';
        -:  166:      }
        -:  167:      // Trim lines at comment characters
     4113:  168:      if(currentLine[i]=='#'||currentLine[i]=='\n'){
      288:  169:         currentLine[i]='\0';
      288:  170:         break;
        -:  171:      }
        -:  172:      // Check if there are any non-space characters
     3825:  173:      if(currentLine[i] != ' '){
     2997:  174:         emptyLine=0;
        -:  175:      }
        -:  176:   }
      288:  177:   return !emptyLine;
        -:  178:}
        -:  179:
        -:  180:/**
        -:  181: * Function to load the trace file information in the program. It returns -1 when it encounters errors.
        -:  182: * It allocates memory, freeMemory() should be called when the memory operations read are no longer necessary.
        -:  183: */
        4:  184:int readTraceFile(char * filename){
        4:  185:   numberOfOperations = 0;
        4:  186:   int errors = 0;
        4:  187:   int numberOfLines = countLines(filename);
        4:  188:   if(numberOfLines == -1){
    #####:  189:      return -1;
        -:  190:   }
        -:  191:   FILE *file;
        4:  192:   char *currentLine = NULL;
        4:  193:   size_t len = 0;
        -:  194:   size_t read;
        -:  195:
        4:  196:   file=fopen(filename, "r");
        4:  197:   if (file == NULL){
    #####:  198:      fprintf(stderr,"Error: can not open file %s.\n",filename);
    #####:  199:      return -1;
        -:  200:   }
        -:  201:
        4:  202:   memoryOperations=NULL;
        4:  203:   if(!useGUI){
        2:  204:           if((memoryOperations = malloc(sizeof(struct memOperation)*numberOfLines)) == NULL){
    #####:  205:               fprintf(stderr,"Execution failure: It was not possible to allocate memory.\n");
    #####:  206:               return -1;
        -:  207:           }
        -:  208:   }
        -:  209:
        4:  210:   int currentLineNumber=0;
        -:  211:
        4:  212:   if(useGUI){
        2:  213:         buffer = gtk_text_buffer_new (NULL);
        -:  214:   }
        -:  215:   // Read all the lines in the file
      136:  216:   while ((read = getline(&currentLine, &len, file)) != -1) {
      128:  217:      currentLineNumber++;
      128:  218:      if(useGUI){
       64:  219:            insertTextInBuffer(currentLine, buffer);
        -:  220:      }
        -:  221:
        -:  222:      // Skip empty lines
      128:  223:      if(!preprocessTraceLine(currentLine)){
       32:  224:         continue;
        -:  225:      }
        -:  226:
       96:  227:      struct memOperation *currentMemOperation=NULL;
        -:  228:      
        -:  229:      //if there is not gui data will be stored. I there is gui thre is not need to store as lines will be parsed at execution time
       96:  230:      if(!useGUI){
       48:  231:           currentMemOperation=&memoryOperations[numberOfOperations];
        -:  232:      }
        -:  233:
       96:  234:      if(parseLine(currentLine, currentLineNumber, currentMemOperation) == -1){
    #####:  235:      	      errors++;
        -:  236:      }
        -:  237:
        -:  238:      // Increment the number of memory operations read from the file
       96:  239:      numberOfOperations++;
        -:  240:   }
        -:  241:
        -:  242: 
        4:  243:   if(errors==0){
        -:  244:#if DEBUG
        4:  245:      if(!useGUI){
        2:  246:      	   showOperations();
        -:  247:      }
        4:  248:      fprintf(stderr,"\nTracefile was loaded correctly\n");
        -:  249:#endif
        4:  250:      return 0;
        -:  251:   }
    #####:  252:   fprintf(stderr,"\n");
        -:  253:
    #####:  254:   return -1;
        -:  255:}
        -:  256:
        -:  257:/**
        -:  258: * Count the number of lines in the file. Returns -1 on errors.
        -:  259: */
        4:  260:int countLines(char* filename){
        -:  261:   FILE *fp;
        4:  262:   int count = 0;
        -:  263:   char c; 
        -:  264:
        4:  265:   if ((fp = fopen(filename, "r")) == NULL)
    #####:  266:      return -1;
        -:  267:
     6104:  268:   for (c = getc(fp); c != EOF; c = getc(fp))
     6100:  269:      if (c == '\n')
      128:  270:         count = count + 1;
        4:  271:   fclose(fp);
        4:  272:   return count;
        -:  273:}
        -:  274:
        -:  275:/**
        -:  276: * Free memory allocated by this module.
        -:  277: */
        4:  278:void freeMemory(){
        4:  279:   if(memoryOperations != NULL){
        2:  280:      free(memoryOperations);
        2:  281:      memoryOperations=NULL;
        -:  282:   }
        4:  283:}
        -:  284:
