        -:    0:Source:datainterface.c
        -:    0:Graph:datainterface.gcno
        -:    0:Data:datainterface.gcda
        -:    0:Runs:17
        -:    0:Programs:1
        -:    1:#include <math.h>
        -:    2:#include "datamanipulation.h"
        -:    3:#include "datainterface.h"
        -:    4:
        -:    5://colors defined to be used in the program
        -:    6:const char* const colores[]={"blue", "black", "yellow", "green", "red", "grey", "orange", "purple", "pink", "lightblue", "lightgreen", "white"};
        -:    7:
        -:    8:/**
        -:    9: * This function sets memory to its initial state.
        -:   10: */
        3:   11:void resetMemory() {
        -:   12:   GtkTreeIter iter;	
        -:   13:   //get iterator at position 0
        3:   14:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(modelMEMORY),
        -:   15:         &iter,
        -:   16:         "0");
        -:   17:   //this is the number of words in the whole memory
        3:   18:   int numWords=memory.size/(cpu.word_width/8);
        -:   19:   //for the n words in the mory
     1539:   20:   for(int i=memory.page_base_address; i<memory.page_base_address+memory.page_size; i+=(cpu.word_width/8)){
        -:   21:      char address[50];
        -:   22:      char content[50];
        -:   23:      //obtain adrress in string format
     1536:   24:      sprintf(address, "%0*x", (int)cpu.address_width/4, i);
        -:   25:      //set initial content to 0 
     1536:   26:      sprintf(content, "%0*x", (int)cpu.word_width/4, 0);
        -:   27:      /* Fill fields with data */
     1536:   28:      gtk_list_store_set (modelMEMORY, &iter,
        -:   29:            CONTENT, content,
        -:   30:            ADDRESS, address,
        -:   31:            COLOR, "white",
        -:   32:            USER_CONTENT, NULL,
        -:   33:            -1);
        -:   34:      //move iter to next position to write the next memory word
     1536:   35:      gtk_tree_model_iter_next (GTK_TREE_MODEL(modelMEMORY),
        -:   36:            &iter);
        -:   37:   }
        3:   38:}
        -:   39:/**
        -:   40: * This function resets a unified cache. Sets the data cache to its initial state.
        -:   41: * @param level where the cache is located. 
        -:   42: */
        3:   43:void resetCache(int level){
        -:   44:   //I reset data cache as I had defined unified caches as divided caches which don't have instruction cache. Just to make it easier.
        3:   45:   resetDataCache(level);
        3:   46:}
        -:   47:/**
        -:   48: * This function resets a Data cache. Sets the data cache to its initial state.
        -:   49: * @param cache level where the cache is located. 
        -:   50: */
        6:   51:void resetDataCache(int level){
        -:   52:   //some memory hierarchy properties that will be used later
        6:   53:   int numLines=caches[level].size/caches[level].line_size;
        6:   54:   int lineSize=caches[level].line_size;
        6:   55:   int asociativity=caches[level].asociativity;
        6:   56:   int numsets=numLines/asociativity;
        6:   57:   int numWords=(caches[level].line_size*8)/cpu.word_width;
        -:   58:   //if cache is divided cache size is half
        6:   59:   if(caches[level].separated){
        3:   60:      numLines/=2;
        -:   61:   }
        -:   62:   //this is for filling each field with the correct amount of bits it must be represented with.
        6:   63:   int hexDigsSet=ceil(log(numsets)/log(16));
        6:   64:   int hexDigsLine=ceil(log(numLines)/log(16));
        6:   65:   int hexDigsTag=(cpu.address_width/4)-hexDigsSet-ceil(log(lineSize)/log(16));
        -:   66:   struct cacheLine* line;
        6:   67:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelData);
        -:   68:   GtkTreeIter iter;
        -:   69:   //get iter at first position
        6:   70:   gtk_tree_model_get_iter_first (model, &iter);
        -:   71:   //set each field to its initial value
        -:   72:   char cache_line[100];
        -:   73:   char cache_tag[100];
        -:   74:   char cache_set[100];
        6:   75:   void *user_content=NULL;
        6:   76:   int valid=0;
        6:   77:   int dirty=0;
        6:   78:   int times_accessed=0;
        6:   79:   int last_accessed=0;
        6:   80:   long cache_content[numWords];
        -:   81:   char cache_content_char[2000];
      102:   82:   for(int i=0; i<numWords; i++){
       96:   83:      cache_content[i]=0;
        -:   84:   }
        -:   85:   //this converts form long array to string representation.
        -:   86:
        6:   87:   contentArrayToString(cache_content, cache_content_char, (caches[level].line_size*8)/cpu.word_width, cpu.word_width/4);
        -:   88:   //I write all the reseted fields in each cache line
      582:   89:   for(int i=0; i<numLines; i++){ 
      576:   90:      sprintf(cache_line, "%0*x", hexDigsLine, i);
      576:   91:      sprintf(cache_tag, "%0*x", hexDigsTag, 0);
      576:   92:      sprintf(cache_set, "%0*x", hexDigsSet, i/asociativity);
      576:   93:      gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:   94:            LINE, &cache_line,
        -:   95:            TAG, &cache_tag,
        -:   96:            SET, &cache_set,
        -:   97:            CONTENT_CACHE, cache_content_char,
        -:   98:            USER_CONTENT_CACHE, user_content,
        -:   99:            VALID, valid,
        -:  100:            DIRTY, dirty,
        -:  101:            TIMES_ACCESSED, times_accessed,
        -:  102:            LAST_ACCESSED, last_accessed,
        -:  103:            COLOR_CACHE, colores[WHITE],
        -:  104:            -1);
        -:  105:      //move iter to next position
      576:  106:      gtk_tree_model_iter_next (GTK_TREE_MODEL(model), &iter);
        -:  107:   }
        6:  108:} 
        -:  109:/**
        -:  110: * This function resets a Instruction cache. Sets the data cache to its initial state.
        -:  111: * @param level where the cache is located. 
        -:  112: */
        3:  113:void resetInstructionCache(int level){
        -:  114:   //some memory hierarchy properties that will be used later
        3:  115:   int numLines=caches[level].size/caches[level].line_size;
        3:  116:   int lineSize=caches[level].line_size;
        3:  117:   int asociativity=caches[level].asociativity;
        3:  118:   int numsets=numLines/asociativity;
        3:  119:   int numWords=(caches[level].line_size*8)/cpu.word_width;
        -:  120:   //if cache is divided cache size is half
        3:  121:   if(caches[level].separated){
        3:  122:      numLines/=2;
        -:  123:   }
        -:  124:   //this is for filling each field with the correct amount of bits it must be represented with.
        3:  125:   int hexDigsSet=ceil(log(numsets)/log(16));
        3:  126:   int hexDigsLine=ceil(log(numLines)/log(16));
        3:  127:   int hexDigsTag=(cpu.address_width/4)-hexDigsSet-ceil(log(lineSize)/log(16));
        -:  128:   struct cacheLine* line;
        3:  129:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelInstruction);
        -:  130:   GtkTreeIter iter;
        -:  131:   //get iter at first position
        3:  132:   gtk_tree_model_get_iter_first (model, &iter);
        -:  133:   //set each field to its initial value
        -:  134:   char cache_line[100];
        -:  135:   char cache_tag[100];
        -:  136:   char cache_set[100];
        3:  137:   void *user_content=NULL;
        3:  138:   int valid=0;
        3:  139:   int dirty=0;
        3:  140:   int times_accessed=0;
        3:  141:   int last_accessed=0;
        3:  142:   long cache_content[numWords];
        -:  143:   char cache_content_char[2000];
       51:  144:   for(int i=0; i<numWords; i++){
       48:  145:      cache_content[i]=0;
        -:  146:   }
        -:  147:   //this converts form long array to string representation.
        3:  148:   contentArrayToString(cache_content, cache_content_char, (caches[level].line_size)/(cpu.word_width/8), cpu.word_width/4);
        -:  149:   //I write the all the reseted fields in each cache line
      387:  150:   for(int i=0; i<numLines; i++){ 
      384:  151:      sprintf(cache_line, "%0*x", hexDigsLine, i);
      384:  152:      sprintf(cache_tag, "%0*x", hexDigsTag, 0);
      384:  153:      sprintf(cache_set, "%0*x", hexDigsSet, i/asociativity);
      384:  154:      gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:  155:            LINE, &cache_line,
        -:  156:            TAG, &cache_tag,
        -:  157:            SET, &cache_set,
        -:  158:            CONTENT_CACHE, cache_content_char,
        -:  159:            USER_CONTENT_CACHE, user_content,
        -:  160:            VALID, valid,
        -:  161:            DIRTY, dirty,
        -:  162:            TIMES_ACCESSED, times_accessed,
        -:  163:            LAST_ACCESSED, last_accessed,
        -:  164:            COLOR_CACHE, colores[WHITE],
        -:  165:            -1);
        -:  166:      //move iter to next position
      384:  167:      gtk_tree_model_iter_next (GTK_TREE_MODEL(model), &iter);
        -:  168:   }
        3:  169:} 
        -:  170:/**
        -:  171: * This function shows all the values contained in the fields of a unified cache line
        -:  172: * @param level which will be shown
        -:  173: * @param i line index
        -:  174: */
    #####:  175:void showCacheLine(int level, int i){
        -:  176:   //I show data cache as I had defined unified caches as divided caches which don't have instruction cache. Just to make it easier.
    #####:  177:   showCacheLineData(level, i);
    #####:  178:}
        -:  179:/**
        -:  180: * This function reads a cache line.
        -:  181: * @param level which will be read
        -:  182: * @param line. A pointer to a struct cacheLine were data will be placed. User must free line.content after calling the function. 
        -:  183: * @param i line index
        -:  184: */
    #####:  185:void readLineCache(int level, struct cacheLine* line, int i){
        -:  186:   //I read data cache as I had defined unified caches as divided caches which don't have instruction cache. Just to make it easier.
    #####:  187:   readLineCacheData(level, line, i);
    #####:  188:}
        -:  189:/**
        -:  190: * This function shows all the values contained in the fields of a data cache line
        -:  191: * @param level which will be shown
        -:  192: * @param i line index
        -:  193: */
        3:  194:void showCacheLineData(int level, int i){
        -:  195:   struct cacheLine line;
        -:  196:   //first I read it
        3:  197:   readLineCacheData(level, &line, i);
        -:  198:   char contentString[2000];
        3:  199:   contentArrayToString((line).content, contentString, (caches[level].line_size*8)/cpu.word_width, cpu.word_width/4);
        -:  200:   //I print the values.
        3:  201:   printf("------------------------------------------------------\n");
        3:  202:   printf("line: %lx     tag: %lx    set: %lx\n", line.line, line.tag, line.set);
        3:  203:   printf("content: %s\n", contentString);
        3:  204:   printf("user content: %s\n", (char*)line.user_content);
        3:  205:   printf("valid: %d   dirty: %d   last accessed: %d  times accessed: %d\n", line.valid, line.dirty, line.last_accessed, line.times_accessed);
        3:  206:   printf("------------------------------------------------------\n");
        3:  207:   free(line.content);
        3:  208:}
        -:  209:/**
        -:  210: * This function reads a data cache line.
        -:  211: * @param level which will be read
        -:  212: * @param line. A pointer to a struct cacheLine were data will be placed. User must free line.content after calling the function. 
        -:  213: * @param i line index
        -:  214: */
        3:  215:void readLineCacheData(int level, struct cacheLine* line, int i){
        3:  216:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelData);
        -:  217:   GtkTreeIter iter;
        -:  218:   char iterstring[50];
        -:  219:   //this is the line index in string format
        3:  220:   sprintf(iterstring, "%d", i);	
        -:  221:   //I get an iter pointing to the line which will be read
        3:  222:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  223:         &iter,
        -:  224:         iterstring);
        -:  225:   //this is for temporally storing read values 
        -:  226:   char* a;
        -:  227:   char* b;
        -:  228:   char* c;
        -:  229:   char* d;
        -:  230:   void* e;
        -:  231:   int f;
        -:  232:   int g;
        -:  233:   int h;
        -:  234:   int j;
        -:  235:   //read the values from data sruct
        3:  236:   gtk_tree_model_get (GTK_TREE_MODEL(model), &iter,
        -:  237:         LINE, &a,
        -:  238:         TAG, &b,
        -:  239:         SET, &c,
        -:  240:         CONTENT_CACHE, &d,
        -:  241:         USER_CONTENT_CACHE, &e,
        -:  242:         VALID, &f,
        -:  243:         DIRTY, &g,
        -:  244:         TIMES_ACCESSED, &h,
        -:  245:         LAST_ACCESSED, &j,
        -:  246:         -1);
        -:  247:   //number of words in a cache line
        3:  248:   int numWords = (caches[level].line_size*8)/cpu.word_width;
        -:  249:   long *array;
        3:  250:   array = malloc((sizeof(long))*numWords);
        -:  251:   //turn String format to long array.
        -:  252:   //contentStringToArray(array, d, level);
        3:  253:   contentStringToArray(array, d, numWords);
        -:  254:   //place values in struct return param so that caller user can get them
        3:  255:   line->line = strtol(a, NULL, 16);
        3:  256:   line->tag = strtol(b, NULL, 16);
        3:  257:   line->set = strtol(c, NULL, 16);
        3:  258:   line->content = array;
        3:  259:   line->user_content = e;
        3:  260:   line->valid = f;
        3:  261:   line->dirty = g;
        3:  262:   line->times_accessed = h;
        3:  263:   line->last_accessed = j;
        3:  264:}
        -:  265:/**
        -:  266: * This function reads a instruction cache line.
        -:  267: * @param level which will be read
        -:  268: * @param line A pointer to a struct cacheLine were data will be placed. User must free line.content after calling the function. 
        -:  269: * @param i line index
        -:  270: */
        3:  271:void readLineCacheInstructions(int level, struct cacheLine* line, int i){
        3:  272:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelInstruction);
        -:  273:   GtkTreeIter iter;
        -:  274:   char iterstring[50];
        -:  275:   //this is the line index in string format
        3:  276:   sprintf(iterstring, "%d", i);	
        -:  277:   //I get an iter pointing to the line which will be read
        3:  278:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  279:         &iter,
        -:  280:         iterstring);
        -:  281:   //this is for temporally storing read values 
        -:  282:   char* a;
        -:  283:   char* b;
        -:  284:   char* c;
        -:  285:   char* d;
        -:  286:   void* e;
        -:  287:   int f;
        -:  288:   int g;
        -:  289:   int h;
        -:  290:   int j;
        -:  291:   //read the values from data sruct
        3:  292:   gtk_tree_model_get (GTK_TREE_MODEL(model), &iter,
        -:  293:         LINE, &a,
        -:  294:         TAG, &b,
        -:  295:         SET, &c,
        -:  296:         CONTENT_CACHE, &d,
        -:  297:         USER_CONTENT_CACHE, &e,
        -:  298:         VALID, &f,
        -:  299:         DIRTY, &g,
        -:  300:         TIMES_ACCESSED, &h,
        -:  301:         LAST_ACCESSED, &j,
        -:  302:         -1);
        -:  303:   //number of words in a cache line
        3:  304:   int numWords=(caches[level].line_size*8)/cpu.word_width;
        -:  305:   long *array;
        3:  306:   array=malloc((sizeof(long))*numWords);
        -:  307:   //turn String format to long array.
        3:  308:   contentStringToArray(array, d, level);
        -:  309:   //place values in struct return param so that caller user can get them
        3:  310:   (*line).line=strtol(a, NULL, 16);
        3:  311:   (*line).tag=strtol(b, NULL, 16);
        3:  312:   (*line).set=strtol(c, NULL, 16);
        3:  313:   (*line).content=array;
        3:  314:   (*line).user_content=e;
        3:  315:   (*line).valid=f;
        3:  316:   (*line).dirty=g;
        3:  317:   (*line).times_accessed=h;
        3:  318:   (*line).last_accessed=j;
        3:  319:}
        -:  320:/**
        -:  321: * This function reads a Instruction cache line.
        -:  322: * @param level which will be read
        -:  323: * @param cacheLine. A pointer to a struct cacheLine were data will be placed. User must free line.content after calling the function. 
        -:  324: * @param i line index
        -:  325: */
        3:  326:void showCacheLineInstructions(int level, int i){
        -:  327:   struct cacheLine line;
        -:  328:   //I read the cache line
        3:  329:   readLineCacheInstructions(level, &line, i);
        -:  330:   char contentString[2000];
        3:  331:   contentArrayToString((line).content, contentString, (caches[level].line_size*8)/cpu.word_width, cpu.word_width/4);
        -:  332:   //I print the values of each field
        3:  333:   printf("------------------------------------------------------\n");
        3:  334:   printf("line: %lx     tag: %lx    set: %lx\n", line.line, line.tag, line.set);
        3:  335:   printf("content:%s\n", contentString);
        3:  336:   printf("user content: %s\n", (char*)line.user_content);
        3:  337:   printf("valid: %d   dirty: %d   last accessed: %d  times accessed: %d\n", line.valid, line.dirty, line.last_accessed, line.times_accessed);
        3:  338:   printf("------------------------------------------------------\n");
        3:  339:   free(line.content);
        3:  340:}
        -:  341:/**
        -:  342: * This function writes a cache line.
        -:  343: * @param level which will be written
        -:  344: * @param line. A pointer to a struct cacheLine containing the data to be written.
        -:  345: * @param i line index
        -:  346: */
        3:  347:void writeLineCache(int level, struct cacheLine* line, int i){
        3:  348:   writeLineCacheData(level, line, i);
        3:  349:}
        -:  350:/**
        -:  351: * This function writes a data cache line.
        -:  352: * @param level which will be written
        -:  353: * @param cacheLine. A pointer to a struct cacheLine containing the data to be written.
        -:  354: * @param i line index
        -:  355: */
     1158:  356:void writeLineCacheData(int level, struct cacheLine* line, int i){
     1158:  357:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelData);
        -:  358:   GtkTreeIter iter;
        -:  359:   char iterstring[50];
     1158:  360:   sprintf(iterstring, "%d", i);	
        -:  361:   char a[100];
        -:  362:   char b[100];
        -:  363:   char c[100];
        -:  364:   void *d;
        -:  365:   int f;
        -:  366:   int g;
        -:  367:   int h;
        -:  368:   int j;
     1158:  369:   int numLines=caches[level].size/caches[level].line_size;
     1158:  370:   int lineSize=caches[level].line_size;
     1158:  371:   int asociativity=caches[level].asociativity;
     1158:  372:   int numsets=numLines/asociativity;
     1158:  373:   int numWords=(caches[level].line_size*8)/cpu.word_width;
     1158:  374:   int hexDigsSet=ceil(log(numsets)/log(16));
     1158:  375:   int hexDigsLine=ceil(log(numLines)/log(16));
     1158:  376:   int hexDigsTag=(cpu.address_width/4)-hexDigsSet-ceil(log(lineSize)/log(16));
     1158:  377:   sprintf(a, "%0*lx", hexDigsLine, (*line).line);
     1158:  378:   sprintf(b, "%0*lx", hexDigsTag,  (*line).tag);
     1158:  379:   sprintf(c, "%0*lx", hexDigsSet,  (*line).set);
     1158:  380:   d=(*line).user_content;
     1158:  381:   f=(*line).valid;
     1158:  382:   g=(*line).dirty;
     1158:  383:   h=(*line).times_accessed;
     1158:  384:   j=(*line).last_accessed;
        -:  385:   char contentString[2000];
     1158:  386:   contentArrayToString((*line).content, contentString, (caches[level].line_size*8)/cpu.word_width, cpu.word_width/4);
     1158:  387:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  388:         &iter,
        -:  389:         iterstring);
     1158:  390:   gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:  391:         LINE, &a,
        -:  392:         TAG, &b,
        -:  393:         SET, &c,
        -:  394:         CONTENT_CACHE, contentString,
        -:  395:         USER_CONTENT_CACHE, d,
        -:  396:         VALID, f,
        -:  397:         DIRTY, g,
        -:  398:         TIMES_ACCESSED, h,
        -:  399:         LAST_ACCESSED, j,
        -:  400:         -1);
     1158:  401:}
        -:  402:/**
        -:  403: * This function writes a Instruction cache line.
        -:  404: * @param level which will be written
        -:  405: * @param line  A pointer to a struct cacheLine containing the data to be written.
        -:  406: * @param i line index
        -:  407: */
      768:  408:void writeLineCacheInstructions(int level, struct cacheLine* line, int i){
      768:  409:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelInstruction);
        -:  410:   GtkTreeIter iter;
        -:  411:   char iterstring[50];
      768:  412:   sprintf(iterstring, "%d", i);	
        -:  413:   char a[100];
        -:  414:   char b[100];
        -:  415:   char c[100];
        -:  416:   void* d;
        -:  417:   int f;
        -:  418:   int g;
        -:  419:   int h;
        -:  420:   int j;
      768:  421:   int numLines=caches[level].size/caches[level].line_size;
      768:  422:   int lineSize=caches[level].line_size;
      768:  423:   int asociativity=caches[level].asociativity;
      768:  424:   int numsets=numLines/asociativity;
      768:  425:   int numWords=(caches[level].line_size*8)/cpu.word_width;
      768:  426:   int hexDigsSet=ceil(log(numsets)/log(16));
      768:  427:   int hexDigsLine=ceil(log(numLines)/log(16));
      768:  428:   int hexDigsTag=(cpu.address_width/4)-hexDigsSet-ceil(log(lineSize)/log(16));
      768:  429:   sprintf(a, "%0*lx", hexDigsLine, (*line).line);
      768:  430:   sprintf(b, "%0*lx", hexDigsTag,  (*line).tag);
      768:  431:   sprintf(c, "%0*lx", hexDigsSet,  (*line).set);
      768:  432:   d=(*line).user_content;
      768:  433:   f=(*line).valid;
      768:  434:   g=(*line).dirty;
      768:  435:   h=(*line).times_accessed;
      768:  436:   j=(*line).last_accessed;
        -:  437:   char contentString[2000];
      768:  438:   contentArrayToString((*line).content, contentString, (caches[level].line_size*8)/cpu.word_width, cpu.word_width/4);
      768:  439:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  440:         &iter,
        -:  441:         iterstring);
      768:  442:   gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:  443:         LINE, &a,
        -:  444:         TAG, &b,
        -:  445:         SET, &c,
        -:  446:         CONTENT_CACHE, contentString,
        -:  447:         USER_CONTENT_CACHE, d,
        -:  448:         VALID, f,
        -:  449:         DIRTY, g,
        -:  450:         TIMES_ACCESSED, h,
        -:  451:         LAST_ACCESSED, j,
        -:  452:         -1);
      768:  453:}
        -:  454:/**
        -:  455: * This function shows a memory position
        -:  456: * @param i memory address
        -:  457: * @return 0 if correct -1 if not word address error, -2 if out of page error
        -:  458: */
    #####:  459:int showPosicionMemory(int i){
        -:  460:   struct memoryPosition pos;
        -:  461:   //I read the memory position
    #####:  462:   int returned=readPosicionMemory(&pos, i);
    #####:  463:   if(returned!=0){
    #####:  464:      return returned;
        -:  465:   }
        -:  466:   //I print the values
    #####:  467:   printf("------------------------------------------------------\n");
    #####:  468:   printf("address: %lx     content: %lx\n", pos.address, pos.content);
    #####:  469:   printf("user content: %s\n", (char*)pos.user_content);
    #####:  470:   printf("------------------------------------------------------\n");
    #####:  471:   return 0;
        -:  472:}
        -:  473:/**
        -:  474: * This function reads a memory position
        -:  475: * @param pos. Read data will be placed in here. User must take care of freeing pos.content
        -:  476: * @param i memory address
        -:  477: * @return 0 if correct -1 if not word address error, -2 if out of page error
        -:  478: */
    #####:  479:int readPosicionMemory(struct memoryPosition *pos, int i){
    #####:  480:   GtkTreeModel *model= GTK_TREE_MODEL(modelMEMORY);
        -:  481:   GtkTreeIter iter;
        -:  482:   char iterstring[50];
        -:  483:   //if not word address return error
    #####:  484:   if(i%(cpu.word_width/8)!=0){
    #####:  485:      return -1;
        -:  486:   }
        -:  487:   //if out of page return error
    #####:  488:   if(i<memory.page_base_address || i>(memory.page_base_address+memory.page_size)){
    #####:  489:      return -2;
        -:  490:   }
        -:  491:   //get the table row from the memory address
    #####:  492:   i=(i-memory.page_base_address)/(cpu.word_width/8);   
    #####:  493:   sprintf(iterstring, "%d", i);	
    #####:  494:   gtk_tree_model_get_iter_from_string (model,
        -:  495:         &iter,
        -:  496:         iterstring);
        -:  497:   char* a;
        -:  498:   char* b;
    #####:  499:   void* c=NULL;
    #####:  500:   gtk_tree_model_get (model, &iter,
        -:  501:         ADDRESS, &a,
        -:  502:         CONTENT, &b,
        -:  503:         USER_CONTENT, &c,
        -:  504:         -1);
    #####:  505:   (*pos).address=strtol(a, NULL, 16);
    #####:  506:   (*pos).content=strtol(b, NULL, 16);
    #####:  507:   (*pos).user_content=c;
    #####:  508:}
        -:  509:/**
        -:  510: * This function writes a memory position.
        -:  511: * @param pos. Data to be written will be read from this struct.
        -:  512: * @param i memory address
        -:  513: * @return 0 if correct -1 if not word address error, -2 if out of page error
        -:  514: */
        3:  515:int writePosicionMemory(struct memoryPosition *pos, int i){
        3:  516:   GtkTreeModel *model= GTK_TREE_MODEL(modelMEMORY);
        -:  517:   GtkTreeIter iter;
        -:  518:   char iterstring[50];
        -:  519:   //if not word address return error
        3:  520:   if(i%(cpu.word_width/8)!=0){
    #####:  521:      return -1;
        -:  522:   }
        -:  523:   //if out of page return error
        3:  524:   if(i<memory.page_base_address || i>(memory.page_base_address+memory.page_size)){
    #####:  525:      return -2;
        -:  526:   }
        -:  527:   //get the table row from the memory address
        3:  528:   i=(i-memory.page_base_address)/(cpu.word_width/8);   
        3:  529:   sprintf(iterstring, "%d", i);	
        -:  530:   char a[100];
        -:  531:   char b[100];
        3:  532:   void* c=NULL;
        3:  533:   sprintf(a, "%0*lx", (int)cpu.address_width/4, (*pos).address);
        3:  534:   sprintf(b, "%0*lx", (int)cpu.word_width/4, (*pos).content);
        3:  535:   c=(*pos).user_content;
        3:  536:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  537:         &iter,
        -:  538:         iterstring);
        3:  539:   gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:  540:         ADDRESS, &a,
        -:  541:         CONTENT, &b,
        -:  542:         USER_CONTENT, c,
        -:  543:         -1);
        3:  544:}
        -:  545:/**
        -:  546: * This function colours a memory position
        -:  547: * @param i memory address
        -:  548: * @param color. This is an enum type. It tell the function which color to use.
        -:  549: */
        3:  550:int setColorMemoryPosition(int i, int color){
        3:  551:   GtkTreeModel *model= GTK_TREE_MODEL(modelMEMORY);
        -:  552:   GtkTreeIter iter;
        -:  553:   char iterstring[50];
        -:  554:   //if not word address return error
        3:  555:   if(i%(cpu.word_width/8)!=0){
    #####:  556:      return -1;
        -:  557:   }
        -:  558:   //if out of page return error
        3:  559:   if(i<memory.page_base_address || i>(memory.page_base_address+memory.page_size)){
    #####:  560:      return -2;
        -:  561:   }
        -:  562:   //get the table row from the memory address
        3:  563:   i=(i-memory.page_base_address)/(cpu.word_width/8);   
        3:  564:   sprintf(iterstring, "%d", i);	
        3:  565:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  566:         &iter,
        -:  567:         iterstring);
        3:  568:   gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:  569:         COLOR, colores[color],
        -:  570:         -1);
        3:  571:}
        -:  572:/**
        -:  573: * This function colours a data cache line
        -:  574: * @param level which will be coloured.
        -:  575: * @param i memory address
        -:  576: * @param color. This is an enum type. It tells the function which color to use.
        -:  577: */
        6:  578:void setColorDataCacheLine(int level, int i, int color){
        6:  579:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelData);
        -:  580:   GtkTreeIter iter;
        -:  581:   char iterstring[50];
        6:  582:   sprintf(iterstring, "%d", i);	
        6:  583:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  584:         &iter,
        -:  585:         iterstring);
        6:  586:   gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:  587:         COLOR_CACHE, colores[color],
        -:  588:         -1);
        6:  589:}
        -:  590:/**
        -:  591: * This function colours a data cache line
        -:  592: * @param level which will be coloured.
        -:  593: * @param i memory address
        -:  594: * @param color. This is an enum type. It tells the function which color to use.
        -:  595: */
        3:  596:void setColorCacheLine(int level, int i, int color){
        3:  597:   setColorDataCacheLine(level, i, color);
        3:  598:}
        -:  599:/**
        -:  600: * This function colours a Instruction cache line
        -:  601: * @param level which will be coloured.
        -:  602: * @param i memory address
        -:  603: * @param color. This is an enum type. It tells the function which color to use.
        -:  604: */
        3:  605:void setColorInstructionsCacheLine(int level, int i, int color){
        3:  606:   GtkTreeModel *model= GTK_TREE_MODEL(cacheLevels[level].modelInstruction);
        -:  607:   GtkTreeIter iter;
        -:  608:   char iterstring[50];
        3:  609:   sprintf(iterstring, "%d", i);	
        3:  610:   gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL(model),
        -:  611:         &iter,
        -:  612:         iterstring);
        3:  613:   gtk_list_store_set (GTK_LIST_STORE(model), &iter,
        -:  614:         COLOR_CACHE, colores[color],
        -:  615:         -1);
        3:  616:}
        -:  617:/**
        -:  618: * This function sets a memory word position to its initial value
        -:  619: * @param positionIndex to reset
        -:  620: */
    #####:  621:void writeBlankMemoryPosition(long positionIndex){
        -:  622:   struct memoryPosition pos;
    #####:  623:   pos.address=positionIndex*(cpu.word_width/8);
    #####:  624:   pos.content=0;
    #####:  625:   printf("%ld\n", positionIndex );
    #####:  626:   writePosicionMemory(&pos, positionIndex);
    #####:  627:}
        -:  628:/**
        -:  629: * This function sets a cache line to its initial value
        -:  630: * @param level to be written
        -:  631: * @param line to be written
        -:  632: */
      384:  633:void writeBlankCacheLine(int level, long line){
      384:  634:   writeBlankDataCacheLine(level, line);
      384:  635:}
        -:  636:/**
        -:  637: * This function sets a data cache line to its initial value
        -:  638: * @param level to be written
        -:  639: * @param line to be written
        -:  640: */
     1152:  641:void writeBlankDataCacheLine(int level, long line){
     1152:  642:   int numLines=caches[level].size/caches[level].line_size;
     1152:  643:   int asociativity=caches[level].asociativity;
     1152:  644:   int numsets=numLines/asociativity;
     1152:  645:   int numWords=(caches[level].line_size*8)/cpu.word_width;
     1152:  646:   if(caches[level].separated){
      768:  647:      numLines/=2;
        -:  648:   }
        -:  649:   struct cacheLine cacheLineAdd;
     1152:  650:   cacheLineAdd.line=line;
     1152:  651:   cacheLineAdd.set=line/asociativity;
     1152:  652:   cacheLineAdd.tag=0;
     1152:  653:   cacheLineAdd.dirty=0;
     1152:  654:   cacheLineAdd.valid=0;
     1152:  655:   cacheLineAdd.last_accessed=0;
     1152:  656:   cacheLineAdd.times_accessed=0;
     1152:  657:   long lineContent[numWords];
    19584:  658:   for(int i=0; i<numWords; i++){
    18432:  659:      lineContent[i]=0;	
        -:  660:   }
     1152:  661:   cacheLineAdd.content=lineContent;
     1152:  662:   cacheLineAdd.user_content=NULL;
     1152:  663:   writeLineCacheData(level, &cacheLineAdd, line);
     1152:  664:}
        -:  665:/**
        -:  666: * This function sets a Instruction cache line to its initial value
        -:  667: * @param level to be written
        -:  668: * @param line to be written
        -:  669: */
      768:  670:void writeBlankInstructionCacheLine(int level, long line){
      768:  671:   int numLines=caches[level].size/caches[level].line_size;
      768:  672:   int asociativity=caches[level].asociativity;
      768:  673:   int numsets=numLines/asociativity;
      768:  674:   int numWords=(caches[level].line_size*8)/cpu.word_width;
      768:  675:   if(caches[level].separated){
      768:  676:      numLines/=2;
        -:  677:   }
        -:  678:   struct cacheLine cacheLineAdd;
      768:  679:   cacheLineAdd.line=line;
      768:  680:   cacheLineAdd.set=line/asociativity;
      768:  681:   cacheLineAdd.tag=0;
      768:  682:   cacheLineAdd.dirty=0;
      768:  683:   cacheLineAdd.valid=0;
      768:  684:   cacheLineAdd.last_accessed=0;
      768:  685:   cacheLineAdd.times_accessed=0;
      768:  686:   long lineContent[numWords];
    13056:  687:   for(int i=0; i<numWords; i++){
    12288:  688:      lineContent[i]=0;	
        -:  689:   }
      768:  690:   cacheLineAdd.content=lineContent;
      768:  691:   cacheLineAdd.user_content=NULL;
      768:  692:   writeLineCacheInstructions(level, &cacheLineAdd, line);
      768:  693:}
        -:  694:/**
        -:  695: * This function is used to add a property or value to the simulation statistics panel
        -:  696: * @param component String containig the name of the componet
        -:  697: * @param property String containig the name of the component's property
        -:  698: * @param value String containing the value which that property will be setted to.
        -:  699: */
       12:  700:void setStatistics(char* component, char* property, char* value){
       12:  701:   GtkTreeModel *tree_model=estatistics_model;
        -:  702:   GtkTreeIter iter;
       12:  703:   int isntEmpty=gtk_tree_model_get_iter_first (tree_model, &iter);
       12:  704:   int hasNext=1;
       12:  705:   int componentExists=0;
        -:  706:   //Search for the memory hierarchy componet
       60:  707:   while(hasNext&&isntEmpty){
        -:  708:      char *name;
       42:  709:      gtk_tree_model_get (tree_model, &iter,
        -:  710:            COMPONET_OR_PROPERTY, &name, -1);
        -:  711:      //found
       42:  712:      if(!strcmp(component, name)){
        6:  713:         componentExists=1;
        6:  714:         break;
        -:  715:      }
       36:  716:      hasNext=gtk_tree_model_iter_next (tree_model, &iter);
        -:  717:   }
        -:  718:   //If the componet exists I search for the property
       12:  719:   if(componentExists){
        -:  720:      GtkTreeIter child;
        6:  721:      int hasChildren=gtk_tree_model_iter_children (tree_model,
        -:  722:            &child,
        -:  723:            &iter);
        6:  724:      int hasNext=1;
        6:  725:      int propertyExists=0;
        -:  726:      //Search for the componets property
       18:  727:      while(hasNext&&hasChildren){
        -:  728:         char *name;
        9:  729:         gtk_tree_model_get (tree_model, &child,
        -:  730:               COMPONET_OR_PROPERTY, &name, -1);
        -:  731:         //found
        9:  732:         if(!strcmp(property, name)){
        3:  733:            propertyExists=1;
        3:  734:            break;
        -:  735:         }
        6:  736:         hasNext=gtk_tree_model_iter_next (tree_model, &child);
        -:  737:      }
        -:  738:      //If the componet's property exists I set the value
        6:  739:      if(propertyExists){
        3:  740:         gtk_tree_store_set(GTK_TREE_STORE(tree_model), &child,
        -:  741:               //COMPONET_OR_PROPERTY, "probando",
        -:  742:               VALUE, value,
        -:  743:               -1);
        -:  744:         //If the componet's property doesn't exist I add the property and set the value
        -:  745:      }else{
        3:  746:         gtk_tree_store_append(GTK_TREE_STORE(tree_model), &child, &iter);
        3:  747:         gtk_tree_store_set(GTK_TREE_STORE(tree_model), &child,
        -:  748:               COMPONET_OR_PROPERTY, property,
        -:  749:               VALUE, value,
        -:  750:               -1);
        -:  751:      }
        -:  752:      //If the componet doesn't exist I create the componet and the property and I set the value
        -:  753:   }else{
        -:  754:      GtkTreeIter child;
        6:  755:      gtk_tree_store_append(GTK_TREE_STORE(tree_model), &iter, NULL);
        6:  756:      gtk_tree_store_set(GTK_TREE_STORE(tree_model), &iter,
        -:  757:            COMPONET_OR_PROPERTY, component,
        -:  758:            -1);
        6:  759:      gtk_tree_model_iter_children (tree_model,
        -:  760:            &child,
        -:  761:            &iter);
        6:  762:      gtk_tree_store_append(GTK_TREE_STORE(tree_model), &child, &iter);
        6:  763:      gtk_tree_store_set(GTK_TREE_STORE(tree_model), &child,
        -:  764:            COMPONET_OR_PROPERTY, property,
        -:  765:            VALUE, value,
        -:  766:            -1);
        -:  767:   }
       12:  768:}
        -:  769:/**
        -:  770: * This function is used to read a value from the simulation statistics panel
        -:  771: * @param component String containig the name of the componet
        -:  772: * @param property String containig the name of the component's property
        -:  773: * @return String containing th value
        -:  774: */
       12:  775:char* getStatistics(char* component, char* property){
       12:  776:   GtkTreeModel *tree_model=estatistics_model;
        -:  777:   GtkTreeIter iter;
       12:  778:   gtk_tree_model_get_iter_first (tree_model, &iter);
       12:  779:   int hasNext=1;
       12:  780:   int componentExists=0;
        -:  781:   //Search for the memory hierarchy componet
       78:  782:   while(hasNext){
        -:  783:      char *name;
       63:  784:      gtk_tree_model_get (tree_model, &iter,
        -:  785:            COMPONET_OR_PROPERTY, &name, -1);
        -:  786:      //found
       63:  787:      if(!strcmp(component, name)){
        9:  788:         componentExists=1;
        9:  789:         break;
        -:  790:      }
       54:  791:      hasNext=gtk_tree_model_iter_next (tree_model, &iter);
        -:  792:   }
        -:  793:   //If the componet exists I search for the property
       12:  794:   if(componentExists){
        -:  795:      GtkTreeIter child;
        9:  796:      gtk_tree_model_iter_children (tree_model,
        -:  797:            &child,
        -:  798:            &iter);
        9:  799:      int hasNext=1;
        9:  800:      int propertyExists=0;
        -:  801:      //Search for the componet's property
       27:  802:      while(hasNext){
        -:  803:         char *name;
       15:  804:         gtk_tree_model_get (tree_model, &child,
        -:  805:               COMPONET_OR_PROPERTY, &name, -1);
        -:  806:         //found
       15:  807:         if(!strcmp(property, name)){
        6:  808:            propertyExists=1;
        6:  809:            break;
        -:  810:         }
        9:  811:         hasNext=gtk_tree_model_iter_next (tree_model, &child);
        -:  812:      }
        -:  813:      //If the componet's property exists I get the value
        9:  814:      if(propertyExists){
        -:  815:         char* value;
        6:  816:         gtk_tree_model_get(GTK_TREE_MODEL(tree_model), &child,
        -:  817:               //COMPONET_OR_PROPERTY, "probando",
        -:  818:               VALUE, &value,
        -:  819:               -1);
        6:  820:         return value;
        -:  821:      }
        -:  822:   }
        -:  823:   //If the componet or the property don't exist I create the componet and the property and I set the value return param to NULL
        6:  824:   return NULL;
        -:  825:}
